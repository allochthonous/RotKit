import pandas as pd
import numpy as np
import copy
import os
__location__ = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))

import matplotlib.pyplot as plt
from matplotlib.patches import Polygon
import matplotlib.colors as colors
import matplotlib.colorbar as colorbar
import matplotlib.cm as cmx
from mpl_toolkits.basemap import Basemap, shiftgrid
from mpl_toolkits.axes_grid1 import make_axes_locatable

#adds a new ellipse function to Basemap class
def ellipse(self, lon, lat, a, b, az, **kwargs):
    """
    Draws an ellipse on the Earth's surface, centered at lon, lat, with semi-major-axis a and 
    semi-minor axis b (in degrees) with semi-major axis oriented at az degrees wrt N
    
    Ellipse coordinates generated by call to fortran routine make_ell

    Other \**kwargs passed on to matplotlib.patches.Polygon

    RETURNS
        poly : a maptplotlib.patches.Polygon object.

    """
    ax = self._check_ax()
    ell_lats,ell_lons=rotkit_f.make_ell(a,b,az,lat,lon)

    x, y = self(ell_lons, ell_lats)

    poly = Polygon(zip(x,y), **kwargs)
    ax.add_patch(poly)

    # Set axes limits to fit map region.
    self.set_axes_limits(ax=ax)
    return poly

Basemap.ellipse = ellipse

import RotKit_f as rotkit_f

#Imports a table for looking up plate codes - potentially useful when building new rotations?
platecodes=pd.read_table(os.path.join(__location__,'Datafiles/PlateCodes.txt'), header=None, names=['NumCode','LetterCode','Description'],index_col='NumCode')

def find_plate_from_name(text):
    #given a string fragment (e.g., Pacific will return any matches from the plate description. Warning: can return multiple matches!
    return platecodes[platecodes.Description.str.contains(text)]

def find_plate_from_number(code):
    return platecodes.loc[code]

def rotmat_to_pole(rot_matrix):
    pole_lon=np.arctan((rot_matrix[0,2]-rot_matrix[2,0])/(rot_matrix[2,1]-rot_matrix[1,2]))*180/np.pi
    if rot_matrix[2,1]-rot_matrix[1,2]<0. : pole_lon=pole_lon+180
    if pole_lon>180: pole_lon=pole_lon-360
    if pole_lon<-180: pole_lon=pole_lon+360
    toss=np.sqrt((rot_matrix[2,1]-rot_matrix[1,2])**2+(rot_matrix[0,2]-rot_matrix[2,0])**2+(rot_matrix[1,0]-rot_matrix[0,1])**2)
    pole_lat=np.arcsin((rot_matrix[1,0]-rot_matrix[0,1])/toss)*180/np.pi
    temp=(rot_matrix[0,0]+rot_matrix[1,1]+rot_matrix[2,2]-1.0)
    pole_ang=np.arctan(toss/(rot_matrix[0,0]+rot_matrix[1,1]+rot_matrix[2,2]-1.0))*180/np.pi
    if temp<0: pole_ang=pole_ang+180
    return [pole_lat,pole_lon,pole_ang]

def get_stage_rot(rot1,rot2):
    # stage rotation between two poles where rot1, rot2 are arrays of [lat,long,angle]
    A1=rot1.make_rotmat()
    A2=rot2.make_rotmat()
    S=A2*np.transpose(A1)
    stagerot=rotmat_to_pole(S)
    return stagerot
 
def get_vgps(ages,rotmodel,moving_plate,absolute_ref_frame):
    reconstruction_rots=rotmodel.get_rots(moving_plate,absolute_ref_frame,ages)
    if ages[0]>1: reconstruction_rots.rotations=reconstruction_rots.rotations[1:]
    NPole=PointSet('VGP',moving_plate,0,0,pd.DataFrame(np.column_stack(([90.],[0.])),columns=['Lat','Lon']))
    VGPs=[NPole.rotate(rotation) for rotation in reconstruction_rots.invert().rotations]
    return pd.DataFrame([[age,point.LatLons.Lat.values[0],point.LatLons.Lon.values[0]] 
                            for point,age in zip(VGPs,ages)],columns=['Age','Lat','Lon'])



               
                                                                                      
class EulerRotationModel(object):
    """
    Created from a rotation file: assumes presence of header with
    'MovingPlate','FixedPlate','Chron','EndAge','RotLat','RotLong','RotAng','Kappahat','a','b','c','d','e','f','Points','Segs','Plates','DOF','Source'
    Attributes:
        rotationsets: list of rotationsets defined by unique combination of fixed and moving plates
    """      
    def __init__(self, rotfile):
        self.FixedPlate='None'
        rot_data=pd.read_table(rotfile)
        rot_data['StartAge']=0
        rot_data['StartChron']='None'
        self.rotationsets=[]
        for i,row in rot_data.iterrows():
            if i==0:
                CurrentMoving=row.MovingPlate
                CurrentFixed=row.FixedPlate
                rotations=[]
            if row.MovingPlate==CurrentMoving and row.FixedPlate==CurrentFixed:
                rotations.append(EulerRotation(row)) 
            else:
                self.rotationsets.append(FiniteRotationSet(rotations,CurrentMoving,CurrentFixed))
                CurrentMoving=row.MovingPlate
                CurrentFixed=row.FixedPlate
                rotations=[EulerRotation(row)]
        self.rotationsets.append(FiniteRotationSet(rotations,CurrentMoving,CurrentFixed))
        
    def insert_rots(self,newrots):
        for rotationset in newrots.rotationsets:
            self.rotationsets.append(rotationset)              

    def find_pairs(self,plate):
        circuits=[]
        pairs=[rotationset for rotationset in self.rotationsets if (rotationset.MovingPlate==plate)]
        for pair in pairs:
            circuits.append([pair.MovingPlate,pair.FixedPlate])
        pairs=[rotationset for rotationset in self.rotationsets if (rotationset.FixedPlate==plate)] 
        for pair in pairs:
            circuits.append([pair.FixedPlate,pair.MovingPlate])
        return circuits  
     
    def find_circuit(self,startplate,endplate,preferred=-1):
        # should check to see if both startplate and endplate are included in the rotation model...
        circuits=self.find_pairs(startplate)
        plates_used=[startplate]+[pair[-1] for pair in circuits]
        while len(plates_used)<len(self.plates()): #technically, could check for a pair with endplate in it but if that exists this shouldn't be running...
            for circuit in circuits:
                for pair in self.find_pairs(circuit[-1]):
                    if pair[-1] not in plates_used: #because we don't want to go backwards!
                        plates_used.append(pair[-1])
                        circuits.append(circuit+[pair[-1]])
        found=[circuit for circuit in circuits if circuit[-1]==endplate]
        if preferred>0: found=[circuit for circuit in found if preferred in circuit[1:-1]]
        return found
            
    def get_rots(self,movingplate,fixedplate,ages=[],preferred=-1):
        #what we need to do next is make it so that it will return a rotation set with particular age characteristics through interpolation
        #so, theoretically, this should return a single rotationset, because it either exists in its stated or inverted form 
        selected1=[rotationset for rotationset in self.rotationsets if (rotationset.MovingPlate==movingplate) & (rotationset.FixedPlate==fixedplate)]
        selected2=[rotationset.invert() for rotationset in self.rotationsets if (rotationset.MovingPlate==fixedplate) & (rotationset.FixedPlate==movingplate)]
        #more than one rotationset for a defined plate pair: shouldn't happen in a properly set up rotation model/file...
        if len(selected1)+len(selected2)>1: 
            print 'Uh-oh: multiple rotations fit parameters'
            rots_got=[]
        #no rotationset for defined plate pair: next want to see if can construct a circuit from other plate pairs in the model     
        elif selected1==[] and selected2==[]:
            found=self.find_circuit(movingplate,fixedplate,preferred)
            if found: 
                rots_got=found
                toadd=[]
                #if a circuit exists, now add the circuit to get the new parameters
                #note that if more than one circuit is found, currently the first one in the list is used.
                #could potentially have an interactive prompt?
                for plate1,plate2 in zip(reversed(found[0][:-1]),reversed(found[0][1:])):
                    selected1=[rotationset for rotationset in self.rotationsets if (rotationset.MovingPlate==plate1) & (rotationset.FixedPlate==plate2)]
                    selected2=[rotationset.invert() for rotationset in self.rotationsets if (rotationset.MovingPlate==plate2) & (rotationset.FixedPlate==plate1)]
                    if selected1: toadd.append(selected1[0])
                    else: toadd.append(selected2[0])
                rots_got=toadd[0]
                for rotset in toadd[1:]: rots_got=rotset.addrots(rots_got)
            else: 
                print 'Uh-oh: no rotations fit parameters'
                rots_got=[]
        #not sure if these warning messages are the best way to go around it, but if returning nothing should cause any automated process to bork.
        elif selected1: rots_got=selected1[0]
        else: rots_got=selected2[0]
        #now interpolate ages if some have been input
        if ages:
            rots_got=rots_got.interpolate(ages)
        return rots_got
    
    def summary(self):
        return pd.DataFrame([[item.MovingPlate,find_plate_from_number(item.MovingPlate).Description,item.FixedPlate,find_plate_from_number(item.FixedPlate).Description,
                            item.N,item.rotations[0].EndAge,item.rotations[-1].EndAge] for item in self.rotationsets],
                            columns=['MovingPlate','MovingPlateName','FixedPlate','FixedPlateName','N','Youngest','Oldest'])
    def plates(self):
        #list of unique plate IDs
        return list(set([item.MovingPlate for item in self.rotationsets]+[item.FixedPlate for item in self.rotationsets]))

class FiniteRotationSet(object):
    """
    a collection of finite EulerRotations with common moving and fixed plates. Methods to easily list set parameters such as ages, chrons,
    generate interpolated rotations and stage rotations
    """
    def __init__(self, rotations,movingplate,fixedplate):
        #where rotations is a list of EulerRotation objects
        self.MovingPlate=movingplate
        self.FixedPlate=fixedplate
        self.rotations=rotations
        #next bit makes interpolation easier: adds in a zero age rotation if none exists
        if (self.rotations[0].EndAge==0 and self.rotations[0].StartAge==0)==False: #a possibly unneccesarilty more robust check
            newrot=copy.deepcopy(rotations[0]) #creates new rather than referenced copy
            newrot.EndAge=0.
            newrot.StartAge=0.
            newrot.RotPars.RotAng=0.
            self.rotations.insert(0,newrot)
        self.N=len(rotations)
        
    def invert(self, inverting='plate'):
        """
        returns an inverted rotationset by sequentially calling the invert method on each rotation
        By default will also invert the plate codes, set second argument to 'time'
        to invert starting and ending ages for rotation instead.
        """
        return FiniteRotationSet([rotation.invert(inverting) for rotation in self.rotations],self.FixedPlate,self.MovingPlate)
        
    def interpolate(self, ages):
        """ 
        Returns a rotation set of interpolated poles and covariances, for specified list of target ages. 
        Searches for the two bracketing rotations for each target age, following method of Doubrovine and Tarduno (2008). 
        Uses fortran routine ibfrlib0.3.f provided by Pavel Doubrovine, wrapped for python using f2py
        compiled with python wrapped using f2py
        """
        interpolated=[]
        ages.sort() #just in case
        for age in ages:
            age=float(age) #also just in case
            poleages=[item.EndAge for item in self.rotations]
            if age>=min(poleages) and age<=max(poleages):
                #check provided age is within range of given poles
                match=[rotation for rotation in self.rotations if (rotation.EndAge==age)]
                if match:
                    #checks there is a point in interpolating. If a rotation exists with the given age, can just use that.
                    interpolated.append(match[0])
                else: 
                    #get bracketing rotations
                    A1=[rotation for rotation in self.rotations if (rotation.EndAge<age)][-1]
                    A2=[rotation for rotation in self.rotations if (rotation.EndAge>age)][0]
                    xi=(age-A1.EndAge)/(A2.EndAge-A1.EndAge)
                    #do the interpolation by calling finb2       
                    newrot,newcovmat=rotkit_f.finb2(A1.RotPars.tolist(),A1.make_covmat(),A2.RotPars.tolist(),A2.make_covmat(),xi)
                    ndata=(A1.HellingerInfo.Points+A2.HellingerInfo.Points)/2 #not sure if this is justified but need something..
                    #this is admittedly a little clunky, but it does the job.
                    interpolated.append(EulerRotation(pd.Series([A1.MovingPlate,A1.FixedPlate,A1.StartChron,'None',0.,age,
                    newrot[0],newrot[1],newrot[2],
                    1.0,newcovmat[0,0],newcovmat[0,1],newcovmat[0,2],newcovmat[1,1],newcovmat[1,2],newcovmat[2,2],
                    ndata,A1.HellingerInfo.Segs,A1.HellingerInfo.Plates,A1.HellingerInfo.DOF,'Interpolated'],
                    index=['MovingPlate','FixedPlate','StartChron','EndChron','StartAge','EndAge','RotLat','RotLong',
                    'RotAng','Kappahat','a','b','c','d','e','f','Points','Segs','Plates','DOF','Source'])))
        return FiniteRotationSet(interpolated,self.MovingPlate,self.FixedPlate)
                  
    def stagerots(self):
        srots=[]
        #get the stage rotations between each finite rotation in the RotationSet.
        for rot1,rot2 in zip(self.rotations[:-1],self.rotations[1:]): 
            srot=get_stage_rot(rot1.RotPars,rot2.RotPars)
            #calculation of covariance matrix for stage rotation between A1 and A2 = A1*(cov2-cov1)
            #from Appendix to Doubrovine & Tarduno 2008
            cov_matrix_s=rot1.make_rotmat()*(rot2.make_covmat()-rot1.make_covmat())
            #not sure that this is totally valid - may be better to just put in smallest number of points?
            points=(rot1.HellingerInfo.Points+rot2.HellingerInfo.Points)/2
            srots.append(EulerRotation(pd.Series([self.MovingPlate,self.FixedPlate,rot1.EndChron,rot2.EndChron,rot1.EndAge,rot2.EndAge,
                    srot[0],srot[1],srot[2],
                    1.0,cov_matrix_s[0,0],cov_matrix_s[0,1],cov_matrix_s[0,2],cov_matrix_s[1,1],cov_matrix_s[1,2],cov_matrix_s[2,2],
                    points,'NA','NA',10000,'Interpolated Stage Pole'],
                    index=['MovingPlate','FixedPlate','StartChron','EndChron','StartAge','EndAge','RotLat','RotLong',
                    'RotAng','Kappahat','a','b','c','d','e','f','Points','Segs','Plates','DOF','Source'])))    
        return StageRotationSet(srots,self.MovingPlate,self.FixedPlate)
        
    def addrots(self,other_rotset,ages=[],sense='to'):
        #adds this rotationset to another one at specified age steps: if no ages provided will interpolate to all finite rotation ages 
        # Default sense is that you are adding 'to' other_rot, such that the fixed plate of other_rot is the fixed plate for the result.
        # If sense is 'on' then the fixed plate of this rotation will be the fixed plate for the result.
        if not ages:
            ages=list(set(self.summary().EndAge.tolist()+other_rotset.summary().EndAge.tolist()))
            ages.sort()
        if sense=='to':
            rotset1,rotset2=self.interpolate(ages),other_rotset.interpolate(ages)
        else:
            rotset1,rotset2=other_rotset.interpolate(ages),self.interpolate(ages)
        added=[]
        for rot1,rot2 in zip(rotset1.rotations,rotset2.rotations):
            added.append(rot1.addrot(rot2))
        return FiniteRotationSet(added,rotset1.MovingPlate,rotset2.FixedPlate)    
   
    def summary(self):
        return pd.DataFrame([[item.MovingPlate,item.FixedPlate,item.StartAge,item.EndAge,item.RotPars[0],item.RotPars[1],item.RotPars[2]] for item in self.rotations],
                                columns=['MovingPlate','FixedPlate','StartAge','EndAge','RotLat','RotLong','RotAng'])
                

class StageRotationSet(object):
    """
    a collection of stage EulerRotations with common moving and fixed plates. Methods to easily list set parameters such as ages, chrons,
    generate interpolated rotations and stage rotations
    """
    def __init__(self, rotations,movingplate,fixedplate):
        #where rotations is a list of EulerRotation objects
        #note unlike finite rotationset does not add in a zero rotation.
        self.MovingPlate=movingplate
        self.FixedPlate=fixedplate
        self.rotations=rotations
        self.N=len(rotations)
        
    def invert(self):
        """
        returns an inverted rotationset by sequentially calling the invert method on each rotation
        AFAICT inversion is only meaningful in time for stage poles, so currently that is what it does
        """
        inverted=FiniteRotationSet([rotation.invert('time') for rotation in self.rotations],self.MovingPlate,self.FixedPlate)
        #don't want zeroed rotation for stage poles
        inverted.rotations=inverted.rotations[1:]
        return inverted
                          
    def finiterots(self):
        print 'Method not yet implemented'
        #reconstruct the finite rotations by adding the stage rotations. Still to do.
   
    def summary(self):
        return pd.DataFrame([[item.MovingPlate,item.FixedPlate,item.StartAge,item.EndAge,item.RotPars[0],item.RotPars[1],item.RotPars[2]] for item in self.rotations],
                                columns=['MovingPlate','FixedPlate','StartAge','EndAge','RotLat','RotLong','RotAng'])
                                  
class EulerRotation(object):
    """
    Euler rotation for objects on Earth's surface. At the moment it does not make a distinction between finite rotations
    (where one of the age points is 0) and a stage rotation: this may change if different methods are required.
    Attributes:
        MovingPlate: tectonic plate code for moving plate
        FixedPlate: tectonic plate code for fixed plate
        StartAge: starting age of rotation (will normally be 0 for loaded finite rotations)
        StartChron: magnetic chron for starting age ('None' if does not correspond to any chron due to e.g., interpolation)
        EndAge: end age of rotation
        EndChron: magnetic chron for end age ('None' if does not correspond to any chron due to e.g., interpolation)
        RotPars: pandas Series with Latitude, Longitude and Rotation Angle
        Covariances: pandas Series with kappahat and covariance values a,b,c,d,e,f
        HellingerInfo: pandas Series with Points and Segments used for Hellinger fit, 2/3 Plate system, and corresponding degrees of freedom (DOF)
        Source: Published source, or 'Calculated' if created by addition/interpolation etc.
        PlotColor: assigned colour (defaults to black)
    """
    def __init__(self, rotation, plotcolor='black'):
        """Return object
        input is a pandas DataFrame row with neccessary parameters. Should probably try to make it fail gracefully if no covariances?
        the getattr is a way of giving a default value if none is detected. So could potentially do something like that an give default covariances...
        """ 
        self.MovingPlate = rotation.MovingPlate
        self.FixedPlate=rotation.FixedPlate
        self.StartAge=getattr(rotation,'StartAge',0)
        self.EndAge=rotation.EndAge
        self.StartChron=getattr(rotation,'StartChron','None')
        self.EndChron=rotation.EndChron
        self.RotPars=pd.Series([rotation.RotLat,rotation.RotLong,rotation.RotAng],index=['RotLat','RotLong','RotAng'])
        self.Covariances=pd.Series([rotation.Kappahat,rotation.a,rotation.b,rotation.c,rotation.d,rotation.e,rotation.f],
                                    index=['Kappahat','a','b','c','d','e','f'])
        self.HellingerInfo=pd.Series([rotation.Points,rotation.Segs,rotation.Plates,rotation.DOF], index=['Points','Segs','Plates','DOF'])
        self.Source=rotation.Source
        self.PlotColor=plotcolor

    def make_covmat(self):
        return np.matrix([[self.Covariances.a,self.Covariances.b,self.Covariances.c],
                            [self.Covariances.b,self.Covariances.d,self.Covariances.e],
                            [self.Covariances.c,self.Covariances.e,self.Covariances.f]])
                            
    def make_rotmat(self):
        lat,lon,ang=self.RotPars.RotLat*np.pi/180,self.RotPars.RotLong*np.pi/180,self.RotPars.RotAng*np.pi/180,
        num=1-np.cos(ang)
        px=np.cos(lat)*np.cos(lon)
        py=np.cos(lat)*np.sin(lon)
        pz=np.sin(lat)
        return np.matrix([[(px*px*num )+ np.cos(ang),(px*py*num )-(pz*np.sin(ang)),(px*pz*num)+(py*np.sin(ang))],
                    [(py*px*num)+(pz*np.sin(ang)),(py*py*num)+np.cos(ang),(py*pz*num)-(px*np.sin(ang))],
                    [(px*pz*num)-(py*np.sin(ang)),(pz*py*num)+(px*np.sin(ang)),(pz*pz*num)+np.cos(ang)]])

    def invert(self, inverting='plate'):
        """
        Calculate the inverse of a rotation and its convariance matrix
        By default will also invert the plate codes, set second argument to 'time'
        to invert starting and ending ages for rotation instead.
        """
        # calculate inverse rotation and its covariance matrix - adapted from invrot.f (original November 3 1988 J-Y R)
        # a=b**t; cova=b*covb*(b**t) where b, covb =rotation and covariance matrices of original rotation, and a is the transpose of b
        invrot=EulerRotation(self.details())
        invrot.RotPars.RotAng=-invrot.RotPars.RotAng
        rot_matrix=invrot.make_rotmat()
        cov_matrix=invrot.make_covmat()
        t_rot_matrix=np.transpose(rot_matrix)
        inv_cov=rot_matrix*cov_matrix*t_rot_matrix
        invrot.Covariances=pd.Series([invrot.Covariances.Kappahat,inv_cov[0,0],inv_cov[0,1],inv_cov[0,2],inv_cov[1,1],inv_cov[1,2],inv_cov[2,2]],
                                    index=['Kappahat','a','b','c','d','e','f'])
        if inverting=='time': 
            invrot.StartAge=self.EndAge
            invrot.EndAge=self.StartAge
            invrot.StartChron=self.EndChron
            invrot.EndChron=self.StartChron
        else: 
            invrot.FixedPlate=self.MovingPlate
            invrot.MovingPlate=self.FixedPlate
        return invrot
        
    def addrot(self,other_rot,sense='to'):
        #adds together this rotation to another one. 
        # Default sense is that you are adding 'to' other_rot, such that the fixed plate of other_rot is the fixed plate for the result.
        # If sense is 'on' then the fixed plate of this rotation will be the fixed plate for the result.
        # Rotation vector addition adapted from fortran code provided by David Rowley, based on vector addition as described in Cox and Hart  p. 232 and 233
        # Treatment of rotation covariance per Chang 1990 - covariance of combined rotations A and B C=AB, with covariance cova and covb: covc ~= B(t)*covA*B+covB
        # a linear approximation that assumes rotations *associated with the errors* are small enough to be treated as infintesimal so can be added as vectors.
        # Condition for this that det(cova) and det (covb) <<1, which seems to be more than met with typical rotation pole covariances.
        # Adapted from addrot.f (most notes below copied from there) ======  November 3 1988 J-Y R ======= MODIFIED OCTOBER 14, 1991
      
        if sense=='to':
            rot1=EulerRotation(self.details())
            rot2=other_rot
        else:
            rot1=other_rot
            rot2=EulerRotation(self.details())
         
        #1. Check if rotation angles are 0    
        if rot1.RotPars[2]==0 and rot2.RotPars[2]==0: newRotPars=[0,0,0]
        #2. Check if poles are identical (sum to zero)
        elif -rot1.RotPars[2]==rot2.RotPars[2] and rot1.RotPars[0]==rot2.RotPars[0] and rot1.RotPars[1]==rot2.RotPars[1]: newRotPars=[rot1[0],rot1[1],0]
        elif -rot1.RotPars[2]==rot2.RotPars[2] and rot1.RotPars[0]==-rot2.RotPars[0] and rot1.RotPars[1]==rot2.RotPars[1]+180: newRotPars=[rot1[0],rot1[1],0]
        elif -rot1.RotPars[2]==rot2.RotPars[2] and rot1.RotPars[0]==-rot2.RotPars[0] and rot1.RotPars[1]==rot2.RotPars[1]-180: newRotPars=[rot1[0],rot1[1],0]
        else: newRotPars=rotmat_to_pole(rot2.make_rotmat()*rot1.make_rotmat())
        
        #now to deal with covariances. Currently, the kappa estimation when DOF<50 for one or both kappahat is not implemented.
        new_covmat=(np.transpose(rot2.make_rotmat())*(rot2.make_covmat()/rot2.Covariances.Kappahat)
                                *rot2.make_rotmat())+(rot1.make_covmat()/rot1.Covariances.Kappahat)
        newKappa=1
        newDOF=10000
        
        return EulerRotation(pd.Series([rot1.MovingPlate,rot2.FixedPlate,rot1.StartChron,rot2.EndChron,rot1.StartAge,rot2.EndAge,
                    newRotPars[0],newRotPars[1],newRotPars[2],
                    newKappa,new_covmat[0,0],new_covmat[0,1],new_covmat[0,2],new_covmat[1,1],new_covmat[1,2],new_covmat[2,2],
                    rot1.HellingerInfo.Points+rot2.HellingerInfo.Points,'NA','NA',newDOF,'Calculated'],
                    index=['MovingPlate','FixedPlate','StartChron','EndChron','StartAge','EndAge','RotLat','RotLong',
                    'RotAng','Kappahat','a','b','c','d','e','f','Points','Segs','Plates','DOF','Source']))             
    
    def rotate(self,rotation):
        """
        Rotates rotation pole by EulerRotation rotation (i.e. into a different reference frame)
        Most relvevent for stage rotations: makes the FixedPlate/MovingPlate a bit tricky potentially.
        """ 
        result=rotkit_f.rotatepts(np.array([[self.RotPars.RotLat,self.RotPars.RotLong]]),
                np.array([rotation.RotPars.tolist()+rotation.Covariances.tolist()+[rotation.EndAge]]),1)
        return EulerRotation(pd.Series([self.MovingPlate,self.FixedPlate,self.StartChron,self.EndChron,self.StartAge,self.EndAge,result[:,0][0],result[:,1][0],self.RotPars[2],
                        self.Covariances.Kappahat,self.Covariances.a,self.Covariances.b,self.Covariances.c,self.Covariances.d,self.Covariances.e,self.Covariances.f,
                        self.HellingerInfo.Points,self.HellingerInfo.Segs,self.HellingerInfo.Plates,self.HellingerInfo.DOF,self.Source],
                            index=['MovingPlate','FixedPlate','StartChron','EndChron','StartAge','EndAge','RotLat','RotLong','RotAng',
                            'Kappahat','a','b','c','d','e','f','Points','Segs','Plates','DOF','Source']))
    
    def details(self):
        return pd.Series([self.MovingPlate,self.FixedPlate,self.StartChron,self.EndChron,self.StartAge,self.EndAge,self.RotPars[0],self.RotPars[1],self.RotPars[2],
                        self.Covariances.Kappahat,self.Covariances.a,self.Covariances.b,self.Covariances.c,self.Covariances.d,self.Covariances.e,self.Covariances.f,
                        self.HellingerInfo.Points,self.HellingerInfo.Segs,self.HellingerInfo.Plates,self.HellingerInfo.DOF,self.Source],
                            index=['MovingPlate','FixedPlate','StartChron','EndChron','StartAge','EndAge','RotLat','RotLong','RotAng',
                            'Kappahat','a','b','c','d','e','f','Points','Segs','Plates','DOF','Source'])
        
    def summary(self):
        return pd.Series([self.MovingPlate,self.FixedPlate,self.StartAge,self.EndAge,self.RotPars[0],self.RotPars[1],self.RotPars[2]],
                            index=['MovingPlate','FixedPlate','StartAge','EndAge','RotLat','RotLong','RotAng'])   
            

class PointSet(object):
    """ one or more points that can be acted on by rotations
    
        Attributes:
        name: string describing feature
        PlateCode: tectonic plate code on which point(s) are located
        LatLons: pandas DataFrame with Lat and Long points, plus rotation error ellipse parameters
        FeatureAge: age of feature
        ReconstructionAge: age that current set of points has been reconstructed at
        PlotColor: assigned colour
        PlotLevel: plot level (defaults to 5)
    """
    def __init__(self, name,PlateCode,FeatureAge,ReconstructionAge,LatLons,PlotColor='grey',PlotLevel=5):
        """Return object
        NB LatLons should be imported as a pandas dataframe with Lat and Lon columns
        """ 
        self.name = name
        self.PlateCode=PlateCode
        #not sure how much, but information about reference frame could be useful
        self.ReferencePlate=PlateCode
        self.FeatureAge=FeatureAge
        self.ReconstructionAge=ReconstructionAge
        self.LatLons=LatLons
        #if LatLons table does not contain rotation error parameters, creates empty columns 
        if not 'MaxError' in self.LatLons:
            self.LatLons['MaxError']=0
            self.LatLons['MinError']=0
            self.LatLons['MaxBearing']=0
        
        self.PlotColor=PlotColor
        self.PlotLevel=PlotLevel
    
    def mapplot(self,m):
        self.pltx,self.plty=m(self.LatLons.Lon.values,self.LatLons.Lat.values)
        plt.plot(self.pltx,self.plty, 'o', color=self.PlotColor, zorder=self.PlotLevel)
    
    def rotate(self,rotation):
        """Rotates pointset by EulerRotation rotation
        """ 
        #intially tried to make a copy and modify it, but it seems you can call the object type to initialise a new version
        result=rotkit_f.rotatepts(self.LatLons.as_matrix(['Lat','Lon']),
                np.array([rotation.RotPars.tolist()+rotation.Covariances.tolist()+[rotation.EndAge]]),1)
        rotated=type(self)(self.name,self.PlateCode,self.FeatureAge,rotation.EndAge,
                        pd.DataFrame(np.column_stack((result[:,1],result[:,0],result[:,3],result[:,4],result[:,5])),
                        columns=['Lon','Lat','MaxError','MinError','MaxBearing']),
                        self.PlotColor,self.PlotLevel)
        rotated.ReferencePlate=rotation.FixedPlate
        return rotated
    
    def reconstruct(self,age,refplate,rotmodel):
        """
        Finds the EulerRotation for specified age, then rotates it
        """
        #first check if the reference plate is this plate.
        if refplate==self.PlateCode:
            return self
        #another place where adding the zero rotation could trip you up.
        else: return self.rotate(rotmodel.get_rots(self.PlateCode,refplate,[age]).rotations[-1])
    
    def motion_vectors(self,rotation,quadrant='E'):
        """
        calculates the magnitude and direction of the plate motion vector for this locality, given an Euler rotation
        outputs a bearing and a velocity in mm/yr or km/Myr, duration calculated from the rotation start and end ages. 
        Also outputs N-S and E-W components of velocity.
        Quadrant makes sure vector is with specified half quadrant.
        """
        #velocity of point on Earth's surface=cross product of Euler vector (omega) and position vector (r)
        #N-S component of v vNS = a*|rotrate|*cos(polelat)*sin(sitelong-polelong)
        #E-W component of v vEW =  a*|rotrate|* [cos(sitelat)*sin(polelat)-sin(sitelat)*cos(polelat)*cos(sitelong-polelong)]
        #where a=Earth radius
        #rate of motion = sqrt (vNS^2+vEW^2)
        #azimuth = 90-atan[vNS/vEW]
        pointlat=self.LatLons.Lat*np.pi/180
        pointlong=self.LatLons.Lon*np.pi/180
        rotlat=rotation.RotPars.RotLat*np.pi/180
        rotlong=rotation.RotPars.RotLong*np.pi/180
        rotrate=abs(rotation.RotPars.RotAng)*np.pi/180
        vNS=6371.*rotrate*np.cos(rotlat)*np.sin(pointlong-rotlong)
        vEW=6371.*rotrate*(np.cos(pointlat)*np.sin(rotlat)-np.sin(pointlat)*np.cos(rotlat)*np.cos(pointlong-rotlong))
        azimuth=90.-(180/np.pi*np.arctan(vNS/vEW))
        if quadrant=='N':
            azimuth[np.cos(azimuth*np.pi/180.)<0]=azimuth-180.
        elif quadrant=='S':    
            azimuth[np.cos(azimuth*np.pi/180.)>0]=azimuth+180.
        elif quadrant=='W':    
            azimuth[np.sin(azimuth*np.pi/180.)>0]=azimuth+180.
        elif quadrant=='E':    
            azimuth[np.sin(azimuth*np.pi/180.)<0]=azimuth-180.                       
        return pd.DataFrame(np.column_stack((np.sqrt(vNS**2+vEW**2)/abs(rotation.StartAge-rotation.EndAge),
                            azimuth,vNS,vEW)),
                            columns=['Rate','Bearing','NS_component','EW_component'])
  
               
class Boundary(PointSet):        
    """ line that can be acted on by rotations
    
        Attributes (inherited from PointSet):
        name: string describing feature
        PlateCode: tectonic plate code on which point(s) are located
        FeatureAge: age of feature
        ReconstructionAge: age that current set of points has been reconstructed at
        LatLons: pandas DataFrame with Lat and Long points 
        PlotColor: assigned colour
        PlotLevel: plot level (defaults to 5)
    """      
    def mapplot(self,m,thickness=2):
        self.pltx,self.plty=m(self.LatLons.Lon.values,self.LatLons.Lat.values)
        plt.plot(self.pltx,self.plty, linewidth=thickness, color=self.PlotColor, zorder=self.PlotLevel)

class Platelet(PointSet):
    """ closed Polygon that can be acted on by rotations but no defined subsegments as PlatePolygon
    
        Attributes (inherited from PointSet):
        name: string describing feature
        PlateCode: tectonic plate code on which point(s) are located
        FeatureAge: age of feature
        ReconstructionAge: age that current set of points has been reconstructed at
        LatLons: pandas DataFrame with Lat and Long points 
        PlotColor: assigned colour (defaults to grey)
        PlotLevel: plot level (defaults to 5)
    """

    def mapplot(self,m,thickness=2,transparency=0.5):
        """plot polygon on specified basemap"""
        self.pltx,self.plty=m(self.LatLons.Lon.values,self.LatLons.Lat.values)
        self.polygon=Polygon(zip(self.pltx,self.plty),
                             facecolor=self.PlotColor, alpha=transparency, zorder=self.PlotLevel)
        plt.gca().add_patch(self.polygon)
        plt.plot(self.pltx,self.plty, color=self.PlotColor, linewidth=thickness,zorder=self.PlotLevel)
        


#actually going to need pmag only as well; potentially AMS only although not in this study
class AMS_Locality(object):
    """ A sampling site with associated AMS data 
    Attributes:
    name: string describing feature
    PlateCode
    LatLons: a pandas series that contains Latitude, Longitude and if specified error ellipse parameters MaxError,MinError,MaxBearing
    Age_info: a pandas series that contains FeatureAge, FeatureAgeError
    AMS_info: a pandas series that contains AMS ellipsoid information (currently just lineation orientation and error)
    PlotColor: assigned colour
    PlotLevel: plot level (defaults to 5)
    """
    def __init__(self, AMS_data,PlotColor='grey',PlotLevel=5,PlotSymbolSize=2):
        """Return object
        
        """ 
        self.Name=AMS_data.Name
        self.PlateCode=AMS_data.Blockcode
        if not 'MaxError' in AMS_data:
            AMS_data.MaxError=0.
            AMS_data.MinError=0.
            AMS_data.MaxBearing=0.
        self.LatLons=pd.Series([AMS_data.Lat,AMS_data.Long,AMS_data.MaxError,AMS_data.MinError,AMS_data.MaxBearing]
                                ,index=['Lat','Lon','MaxError','MinError','MaxBearing'])
        if not 'ReconstructionAge' in AMS_data:
            AMS_data.ReconstructionAge=0.
        self.Age_info=pd.Series([AMS_data.Age,AMS_data.Age_err,AMS_data.ReconstructionAge],index=['FeatureAge','Age_err','ReconstructionAge'])
        self.AMS_info=pd.Series([AMS_data.AMS_max,AMS_data.max_err],index=['AMS_max','AMS_max_err'])
        self.PlotColor=PlotColor
        self.PlotLevel=PlotLevel
        self.PlotSymbolSize=PlotSymbolSize
        
    def mapplot(self,m,plottrend=-1):
        self.pltx,self.plty=m(self.LatLons.Lon,self.LatLons.Lat)
        plt.plot(self.pltx,self.plty, marker='o',ms=self.PlotSymbolSize, color=self.PlotColor, zorder=self.PlotLevel)
        if plottrend>0:
            trend=self.sigma_1()
            plt.quiver(self.pltx,self.plty,np.sin(trend*np.pi/180.),np.cos(trend*np.pi/180.), pivot='tip',color=self.PlotColor,zorder=self.PlotLevel)
            plt.quiver(self.pltx,self.plty,-np.sin(trend*np.pi/180.),-np.cos(trend*np.pi/180.), pivot='tip',color=self.PlotColor,zorder=self.PlotLevel)
   
    def sigma_1(self, quadrant='E'):
        s1_dir=self.AMS_info.AMS_max+90.
        a,b=np.cos(s1_dir*np.pi/180.), np.sin(s1_dir*np.pi/180.)
        if quadrant=='N':
            if a<0: s1_dir=s1_dir-180.
            elif b<0: s1_dir=s1_dir-360.
        elif quadrant=='S':
            if a>0: s1_dir=s1_dir+180.
        elif quadrant=='W':
            if b>0: s1_dir=s1_dir+180.
        elif quadrant=='E':
            if b<0: s1_dir=s1_dir-180. 
        if s1_dir>360.: s1_dir=s1_dir-360   
        return s1_dir

    def rotate(self,rotation):
        """
        Rotates pointset by EulerRotation rotation
        Also rotates the AMS_max direction: doesn't presently incorporate rotation errors
        """ 
        result=rotkit_f.rotatepts(np.array([[self.LatLons.Lat,self.LatLons.Lon]]),
                np.array([rotation.RotPars.tolist()+rotation.Covariances.tolist()+[rotation.EndAge]]),1)
        rotated=AMS_Locality(pd.Series([self.Name,self.PlateCode,self.Age_info.FeatureAge,self.Age_info.Age_err,rotation.EndAge,
                        result[:,0][0],result[:,1][0],result[:,3][0],result[:,4][0],result[:,5][0],
                        self.AMS_info.AMS_max-rotation.RotPars.RotAng,self.AMS_info.AMS_max_err],
                        index=['Name','Blockcode','Age','Age_err','ReconstructionAge','Lat','Long','MaxError','MinError','MaxBearing','AMS_max','max_err']),
                        self.PlotColor,self.PlotLevel)
        rotated.ReferencePlate=rotation.FixedPlate
        return rotated
    
    def reconstruct(self,age,refplate,rotmodel):
        """
        Finds the EulerRotation for specified age, then rotates it
        """
        #first check if the reference plate is this plate.
        if refplate==self.PlateCode:
            return self
        #another place where adding the zero rotation could trip you up.
        else: return self.rotate(rotmodel.get_rots(self.PlateCode,refplate,[age]).rotations[-1])
        
    def motion_vector(self,rotation,quadrant='E'):
        """
        calculates the magnitude and direction of the plate motion vector for this locality, given an Euler rotation
        outputs a bearing and a velocity in mm/yr or km/Myr, duration calculated from the rotation start and end ages. 
        Also outputs N-S and E-W components of velocity.
        """
        #velocity of point on Earth's surface=cross product of Euler vector (omega) and position vector (r)
        #N-S component of v vNS = a*|rotrate|*cos(polelat)*sin(sitelong-polelong)
        #E-W component of v vEW =  a*|rotrate|* [cos(sitelat)*sin(polelat)-sin(sitelat)*cos(polelat)*cos(sitelong-polelong)]
        #where a=Earth radius
        #rate of motion = sqrt (vNS^2+vEW^2)
        #azimuth = 90-atan[vNS/vEW]
        pointlat=self.LatLons.Lat*np.pi/180
        pointlong=self.LatLons.Lon*np.pi/180
        rotlat=rotation.RotPars.RotLat*np.pi/180
        rotlong=rotation.RotPars.RotLong*np.pi/180
        rotrate=abs(rotation.RotPars.RotAng)*np.pi/180
        vNS=6371.*rotrate*np.cos(rotlat)*np.sin(pointlong-rotlong)
        vEW=6371.*rotrate*(np.cos(pointlat)*np.sin(rotlat)-np.sin(pointlat)*np.cos(rotlat)*np.cos(pointlong-rotlong))
        azimuth=90.-(180/np.pi*np.arctan(vNS/vEW))
        a,b=np.cos(azimuth*np.pi/180.), np.sin(azimuth*np.pi/180.)
        if quadrant=='N':
            if a<0: azimuth=azimuth-180.
        elif quadrant=='S':
            if a>0: azimuth=azimuth+180.
        elif quadrant=='E':
            if b<0: azimuth=azimuth-180.
        elif quadrant=='W':
            if b>0: azimuth=azimuth+180.
        return pd.Series([np.sqrt(vNS**2+vEW**2)/abs(rotation.StartAge-rotation.EndAge),
                            azimuth,vNS,vEW],
                            index=['Rate','Bearing','NS_component','EW_component'])
    
    def strain_history(self,rotmodel,ages,converging_plate,refplate,quadrant='E',converge_on_ref=-1):
        """
        Reconstructs the strain history by rotating the locality according to the rotation model
        then calculating the relative plate motion vector from the stage pole. converge_on_ref option 
        allows you to look at plate motion vector relative to the fixed plate, rather than the deforming block itself
        """
        reconstruction_rots=rotmodel.get_rots(self.PlateCode,refplate,ages)
        if converge_on_ref<0:  
            StageRotations=[]
            #need to rotate stagerots back to reference plate
            for rot, stagerot in zip(reconstruction_rots.rotations, rotmodel.get_rots(converging_plate,self.PlateCode,ages).stagerots().rotations):
                StageRotations.append(stagerot.rotate(rot))
            StageRotations=StageRotationSet(StageRotations,self.PlateCode,converging_plate)
        else:
            StageRotations=rotmodel.get_rots(converging_plate,refplate,ages).stagerots()            
        output=[]
        for rot,stagerot in zip(reconstruction_rots.rotations[1:],StageRotations.invert().rotations):
            rotated=self.rotate(rot)
            vector=rotated.motion_vector(stagerot,quadrant)
            output.append([stagerot.StartAge,stagerot.EndAge,rotated.LatLons.Lat,rotated.LatLons.Lon,vector.Rate,vector.Bearing])
        return pd.DataFrame(output,columns=['StartAge','EndAge','Lat','Lon','Rate','Bearing'])
        
    def predict_DI(self,ages,rotmodel,abs_ref_frame):
        """
        Predicts the Declination and Inclination that should be observed from samples of age ages
        at this site - a range of ages can be used because of the possibility of remagnetisation.
        absolute_ref_frame should be an absolute or hotspot frame of reference (e.g. Pacific=3)
        """
        VGPs=get_vgps(ages,rotmodel,self.PlateCode,3)
        reconstruction_rots=rotmodel.get_rots(self.PlateCode,abs_ref_frame,ages)
        rotated=[self.rotate(rotation) for rotation in reconstruction_rots.rotations[1:]]
        paleoI=[np.arctan(2*np.tan(point.LatLons.Lat*np.pi/180))*180/np.pi for point in rotated]
        pp=np.array(([np.sin((90-vgp_lat)*np.pi/180) for vgp_lat in VGPs.Lat]))
        dphi=np.array(([np.sin((vgp_lon-self.LatLons.Lon)*np.pi/180) for vgp_lon in VGPs.Lon]))
        pm=np.array(([np.sin((90-point.LatLons.Lat)*np.pi/180) for point in rotated]))
        paleoD=np.arcsin(pp*dphi/pm)*180/np.pi
        return pd.DataFrame(np.column_stack((ages,[point.LatLons.Lat for point in rotated],[point.LatLons.Lon for point in rotated],paleoD,paleoI)), 
                                        columns=['Age','Lat','Lon','PredDec','PredInc'])


class PMag_Locality(object):
    """ A sampling site with associated AMS data 
    Attributes:
    name: string describing feature
    PlateCode
    LatLons: a pandas series that contains Latitude, Longitude and if specified error ellipse parameters MaxError,MinError,MaxBearing
    Age_info: a pandas series that contains FeatureAge, FeatureAgeError
    PMag_info: a pandas series that contains ChRM information (
    PlotColor: assigned colour
    PlotLevel: plot level (defaults to 5)
    """
    def __init__(self, AMS_data,PlotColor='grey',PlotLevel=5,PlotSymbolSize=2):
        """Return object
        
        """ 
        self.Name=AMS_data.Name
        self.PlateCode=AMS_data.Blockcode
        if not 'MaxError' in AMS_data:
            AMS_data.MaxError=0.
            AMS_data.MinError=0.
            AMS_data.MaxBearing=0.
        self.LatLons=pd.Series([AMS_data.Lat,AMS_data.Long,AMS_data.MaxError,AMS_data.MinError,AMS_data.MaxBearing]
                                ,index=['Lat','Lon','MaxError','MinError','MaxBearing'])
        if not 'ReconstructionAge' in AMS_data:
            AMS_data.ReconstructionAge=0.
        self.Age_info=pd.Series([AMS_data.Age,AMS_data.Age_err,AMS_data.ReconstructionAge],index=['FeatureAge','Age_err','ReconstructionAge'])
        self.AMS_info=pd.Series([AMS_data.AMS_max,AMS_data.max_err],index=['AMS_max','AMS_max_err'])
        self.PlotColor=PlotColor
        self.PlotLevel=PlotLevel
        self.PlotSymbolSize=PlotSymbolSize   

#class Flowline(object):
#    """
#    A set of points tracking a feature over a range of reconstruction ages
#    Attributes:      
#    name: string describing feature
#    PlateCode: tectonic plate code for point being modelled
#    FixedPlate: code for tectonic plate that point has been rotated relative to to generate flowline  
#    FlowData: pandas DataFrame with Lat and Long points + age and error ellipse parameters for flowline 
#    PlotLevel: plot level (defaults to 5)
#    
#    Methods:
#    plot
#    """
#    def __init__(self,name,MovingPlate,FixedPlate,LineData,PlotLevel=5):
#        self.name = name
#        self.PlateCode=MovingPlate
#        self.FixedPlate=FixedPlate
#        self.FlowData=LineData    # columns should be PointLat,PointLong,Age,ErrEllipseMax,ErrEllipseMin,ErrEllipseMaxBearing
#                                # also assumes that data sorted in age ascending order
#        self.PlotLevel=PlotLevel
#        
#    def mapplot(self,m,colourmap='plasma_r',plotbar='Y'):
#        age_cmap=plt.get_cmap(colourmap)
#        maxage=np.round(max(self.FlowData.Age),-1)
#        minage=np.round(min(self.FlowData.Age),-1)
#        cNorm  = colors.Normalize(vmin=minage, vmax=maxage)
#        scalarMap = cmx.ScalarMappable(norm=cNorm, cmap=age_cmap)
#        for i,thing in self.FlowData[::-1].iterrows():
#            PointColour = scalarMap.to_rgba(thing.Age)
#            x,y= m(thing.PointLong,thing.PointLat)
#            if i<len(self.FlowData)-1:
#                #draw connecting line segment with intermediate colour
#                LineSegColour=scalarMap.to_rgba(thing.Age+((thing.Age-lastAge)/2))
#                x,y=m([x0,thing.PointLong],[y0,thing.PointLat])
#                m.plot(x,y,color=LineSegColour,zorder=3, linewidth=3)
#                m.scatter(x,y,15,color=PointColour,zorder=5)
#            m.ellipse(thing.PointLong,thing.PointLat,thing.ErrEllipseMax,thing.ErrEllipseMin,thing.ErrEllipseMaxBearing,
#                            ec=PointColour,fc='None',linewidth=2,zorder=4)
#            m.ellipse(thing.PointLong,thing.PointLat,thing.ErrEllipseMax,thing.ErrEllipseMin,thing.ErrEllipseMaxBearing,
#                            fc=PointColour,alpha=0.15,linewidth=0,zorder=1)
#            x0,y0=thing.PointLong,thing.PointLat
#            lastAge=thing.Age
#        #add colorbar for age
#        if plotbar=='Y':   
#            ax1 = plt.gca()
#            #sneaky way to extend axes with right dimensions
#            divider=make_axes_locatable(ax1)
#            ax2 = divider.append_axes("bottom", size="5%", pad=0.1)
#            cb1=colorbar.ColorbarBase(ax2, cmap=age_cmap,norm=cNorm,orientation='horizontal')
#            cb1.set_label('Age (Ma)')
#
#
#class ApparentPolarWanderPath(Flowline):
#    """
#    A flowline for paleomagnetic poles - can feed in PoleLat,PoleLong,A95 (or dp/dm) and it will
#    convert that to flowdata comaptible with the plot_ell routine. Dp/dm is potentially tricky because
#    orientation of ellipse depends on the site location relative to the calculated pole - have the information, 
#    just need to make sure it's in the right form
#    """
#    def __init__(self,name,MovingPlate,FixedPlate,PoleData,PlotLevel=5):
#        super().__init__(name,MovingPlate,FixedPlate,PoleData,PlotLevel)
#        #FlowData is not correctly configured from this - need to modify.
#        #currently just deals with A95 data. Will have to modify with conditional to deal with dp/dpm
#        self.FlowData=pd.DataFrame(np.column_stack((PoleData.PoleLat,PoleData.PoleLong,PoleData.Age,PoleData.A95,PoleData.A95,np.repeat(0,len(PoleData)))),
#                                    columns=['PointLat','PointLong','Age','ErrEllipseMax','ErrEllipseMin','ErrEllipseMaxBearing'])
#        #keep PoleData because it is useful
#        self.PoleData=PoleData
#

