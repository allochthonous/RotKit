import pandas as pd
import numpy as np
import copy
import os
__location__ = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))

import matplotlib.pyplot as plt
from matplotlib.patches import Polygon
import matplotlib.colors as colors
import matplotlib.colorbar as colorbar
import matplotlib.cm as cmx
from mpl_toolkits.basemap import Basemap, shiftgrid
from mpl_toolkits.axes_grid1 import make_axes_locatable

#adds a new ellipse function to Basemap class
def ellipse(self, lon, lat, a, b, az, **kwargs):
    """
    Draws an ellipse on the Earth's surface, centered at lon, lat, with semi-major-axis a and 
    semi-minor axis b (in degrees) with semi-major axis oriented at az degrees wrt N
    
    Ellipse coordinates generated by call to fortran routine make_ell

    Other \**kwargs passed on to matplotlib.patches.Polygon

    RETURNS
        poly : a maptplotlib.patches.Polygon object.

    """
    ax = self._check_ax()
    ell_lats,ell_lons=rotkit_f.make_ell(a,b,az,lat,lon)

    x, y = self(ell_lons, ell_lats)

    poly = Polygon(zip(x,y), **kwargs)
    ax.add_patch(poly)

    # Set axes limits to fit map region.
    self.set_axes_limits(ax=ax)
    return poly

Basemap.ellipse = ellipse

import RotKit_f as rotkit_f

#Imports a table for looking up plate codes - potentially useful when building new rotations?
platecodes=pd.read_table(os.path.join(__location__,'Datafiles/PlateCodes.txt'), header=None, names=['NumCode','LetterCode','Description'],index_col='NumCode')

def find_plate_from_name(text):
    #given a string fragment (e.g., Pacific will return any matches from the plate description. Warning: can return multiple matches!
    return platecodes[platecodes.Description.str.contains(text)]

def find_plate_from_number(code):
    return platecodes.loc[code]

def rotmat_to_pole(rot_matrix):
    pole_lon=np.arctan((rot_matrix[0,2]-rot_matrix[2,0])/(rot_matrix[2,1]-rot_matrix[1,2]))*180/np.pi
    if rot_matrix[2,1]-rot_matrix[1,2]<0. : pole_lon=pole_lon+180
    if pole_lon>180: pole_lon=pole_lon-360
    if pole_lon<-180: pole_lon=pole_lon+360
    toss=np.sqrt((rot_matrix[2,1]-rot_matrix[1,2])**2+(rot_matrix[0,2]-rot_matrix[2,0])**2+(rot_matrix[1,0]-rot_matrix[0,1])**2)
    pole_lat=np.arcsin((rot_matrix[1,0]-rot_matrix[0,1])/toss)*180/np.pi
    temp=(rot_matrix[0,0]+rot_matrix[1,1]+rot_matrix[2,2]-1.0)
    pole_ang=np.arctan(toss/(rot_matrix[0,0]+rot_matrix[1,1]+rot_matrix[2,2]-1.0))*180/np.pi
    if temp<0: pole_ang=pole_ang+180
    return [pole_lat,pole_lon,pole_ang]

def sphere_ang_dist(lat1,long1,lat2,long2):
    """
    calculates the length and bearing of the great circle path between two points
    using haversine formula     
    """
    degrad=np.pi/180
    #calculate distance between two points on the Earth's surface - returns value in radians
    #this and other spherical trig routines from http://www.movable-type.co.uk/scripts/latlong.html  
    dlong=(long2-long1)*degrad
    dlat=(lat2-lat1)*degrad
    lat1=lat1*degrad
    lat2=lat2*degrad 
    a=np.sin(dlat/2)*np.sin(dlat/2)+np.cos(lat1)*np.cos(lat2)*np.sin(dlong/2)*np.sin(dlong/2)
    sepdist=2*(np.arctan2(np.sqrt(a),np.sqrt(1-a)))
    return sepdist/degrad
   
def sphere_bearing(lat1,long1,lat2,long2):
    """
    bearing of point (lat2, long2) wrt point (lat1,long1)
    """
    degrad=np.pi/180
    dlong=(long2-long1)*degrad
    lat1=lat1*degrad
    lat2=lat2*degrad
    y = np.sin(dlong)*np.cos(lat2)
    x = np.cos(lat1)*np.sin(lat2)-np.sin(lat1)*np.cos(lat2)*np.cos(dlong)
    bearing=(np.arctan2(y,x))/degrad
    if (bearing<0): bearing=bearing+360
    return bearing

def sphere_point_along_bearing(lat1,long1,bearing,d):
   """
   returns lat and long of points given intial lat/long, bearing and distance
   (all in degrees)
   """        
   degrad=np.pi/180
   lat1,long1,bearing,d=lat1*degrad,long1*degrad,bearing*degrad,d*degrad
   lat2=np.arcsin(np.sin(lat1)*np.cos(d)+np.cos(lat1)*np.sin(d)*np.cos(bearing))
   long2=long1+np.arctan2(np.sin(bearing)*np.sin(d)*np.cos(lat1),np.cos(d)-np.sin(lat1)*np.sin(lat2))
   return lat2/degrad,long2/degrad
                                                                                        
                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                        
class EulerRotationModel(object):
    """
    Created from a rotation file: assumes presence of header with
    'MovingPlate','FixedPlate','Chron','EndAge','RotLat','RotLong','RotAng','Kappahat','a','b','c','d','e','f','Points','Segs','Plates','DOF','Source'
    Attributes:
        rotationsets: list of rotationsets defined by unique combination of fixed and moving plates
    """      
    def __init__(self, rotfile):
        self.FixedPlate='None'
        rot_data=pd.read_table(rotfile)
        rot_data['StartAge']=0
        rot_data['StartChron']='None'
        self.rotationsets=[]
        for i,row in rot_data.iterrows():
            if i==0:
                CurrentMoving=row.MovingPlate
                CurrentFixed=row.FixedPlate
                rotations=[]
            if row.MovingPlate==CurrentMoving and row.FixedPlate==CurrentFixed:
                rotations.append(EulerRotation(row)) 
            else:
                self.rotationsets.append(FiniteRotationSet(rotations,CurrentMoving,CurrentFixed))
                CurrentMoving=row.MovingPlate
                CurrentFixed=row.FixedPlate
                rotations=[EulerRotation(row)]
        self.rotationsets.append(FiniteRotationSet(rotations,CurrentMoving,CurrentFixed))
        
    def insert_rots(self,newrots):
        """
        for adding in newly calculated finite rotations
        given a list of FiniteRotationSets, adds them to the rotation model
        note: currently no consistency checking, so can add conflicting rotations 
        """
        #todo: check for conflicting rotations before adding in new ones.
        for rotationset in newrots:
            self.rotationsets.append(rotationset)
    
    def remove_rots(self,plate1,plate2=-1):
        """
        remove sets of rotations with a particular plate code. If plate2 is specified,
        will remove rotationsets with that plate pair. 
        """
        newrotset=[]
        for rotationset in self.rotationsets:
            #if no plate 2 specified, removes any rotationset with fixed or moving plate with plate1 code.
            #or, if you want to be pedantic, doesn't add it to an updated rotationset list.
            if plate2==-1:
                if (rotationset.MovingPlate==plate1 or rotationset.FixedPlate==plate1) is False:
                    newrotset.append(rotationset)
            #if plate 2 is specified, looks for the plate1-plate2 (or plate2-plate1) pair.
            else:
                if (rotationset.MovingPlate==plate1 and rotationset.FixedPlate==plate2) is False and (rotationset.MovingPlate==plate2 and rotationset.FixedPlate==plate1) is False:
                    newrotset.append(rotationset)
        self.rotationsets=newrotset

    def find_pairs(self,plate):
        circuits=[]
        pairs=[rotationset for rotationset in self.rotationsets if (rotationset.MovingPlate==plate)]
        for pair in pairs:
            circuits.append([pair.MovingPlate,pair.FixedPlate])
        pairs=[rotationset for rotationset in self.rotationsets if (rotationset.FixedPlate==plate)] 
        for pair in pairs:
            circuits.append([pair.FixedPlate,pair.MovingPlate])
        return circuits  
     
    def find_circuit(self,startplate,endplate,preferred=-1):
        # should check to see if both startplate and endplate are included in the rotation model...
        circuits=self.find_pairs(startplate)
        plates_used=[startplate]+[pair[-1] for pair in circuits]
        while len(plates_used)<len(self.plates()): #technically, could check for a pair with endplate in it but if that exists this shouldn't be running...
            for circuit in circuits:
                for pair in self.find_pairs(circuit[-1]):
                    if pair[-1] not in plates_used: #because we don't want to go backwards!
                        plates_used.append(pair[-1])
                        circuits.append(circuit+[pair[-1]])
        found=[circuit for circuit in circuits if circuit[-1]==endplate]
        if preferred>0: found=[circuit for circuit in found if preferred in circuit[1:-1]]
        return found
            
    def get_rots(self,movingplate,fixedplate,ages=[],preferred=-1):
        #what we need to do next is make it so that it will return a rotation set with particular age characteristics through interpolation
        #so, theoretically, this should return a single rotationset, because it either exists in its stated or inverted form 
        selected1=[rotationset for rotationset in self.rotationsets if (rotationset.MovingPlate==movingplate) & (rotationset.FixedPlate==fixedplate)]
        selected2=[rotationset.invert() for rotationset in self.rotationsets if (rotationset.MovingPlate==fixedplate) & (rotationset.FixedPlate==movingplate)]
        #more than one rotationset for a defined plate pair: shouldn't happen in a properly set up rotation model/file...
        if len(selected1)+len(selected2)>1: 
            print 'Uh-oh: multiple rotations fit parameters'
            rots_got=[]
        #no rotationset for defined plate pair: next want to see if can construct a circuit from other plate pairs in the model     
        elif selected1==[] and selected2==[]:
            found=self.find_circuit(movingplate,fixedplate,preferred)
            if found: 
                rots_got=found
                toadd=[]
                #if a circuit exists, now add the circuit to get the new parameters
                #note that if more than one circuit is found, currently the first one in the list is used.
                #could potentially have an interactive prompt?
                for plate1,plate2 in zip(reversed(found[0][:-1]),reversed(found[0][1:])):
                    selected1=[rotationset for rotationset in self.rotationsets if (rotationset.MovingPlate==plate1) & (rotationset.FixedPlate==plate2)]
                    selected2=[rotationset.invert() for rotationset in self.rotationsets if (rotationset.MovingPlate==plate2) & (rotationset.FixedPlate==plate1)]
                    if selected1: toadd.append(selected1[0])
                    else: toadd.append(selected2[0])
                rots_got=toadd[0]
                for rotset in toadd[1:]: rots_got=rotset.addrots(rots_got)
            else: 
                print 'Uh-oh: no rotations fit parameters'
                rots_got=[]
        #not sure if these warning messages are the best way to go around it, but if returning nothing should cause any automated process to bork.
        elif selected1: rots_got=selected1[0]
        else: rots_got=selected2[0]
        #now interpolate ages if some have been input
        if ages:
            rots_got=rots_got.interpolate(ages)
        return rots_got
        
    def synthetic_APWP(self,ages,moving_plate,absolute_ref_frame):
        if ages[0]==0.: ages[0]=0.01 #Gets a bit fussy for the 0 rotation.
        reconstruction_rots=self.get_rots(moving_plate,absolute_ref_frame,ages)
        #At the reconstruction age, the VGP is at the North Pole and then drifts away from it. so use the inverted rotations
        NPole=Point(pd.Series(['VGP',moving_plate,0.,0.,90,0.],index=['Name','PlateCode','FeatureAge','ReconstructionAge','Lat','Lon']))
        VGPs=[NPole.rotate(rotation) for rotation in reconstruction_rots.invert().rotations[1:]] #zero rotation: more trouble than it's worth?   
        return pd.DataFrame([[age,point.LocPars.PointLat,point.LocPars.PointLong] for point,age in zip(VGPs,ages)],
                                columns=['Age','Lat','Lon']) 
           
    def summary(self):
        return pd.DataFrame([[item.MovingPlate,find_plate_from_number(item.MovingPlate).Description,item.FixedPlate,find_plate_from_number(item.FixedPlate).Description,
                            item.N,item.rotations[0].EndAge,item.rotations[-1].EndAge] for item in self.rotationsets],
                            columns=['MovingPlate','MovingPlateName','FixedPlate','FixedPlateName','N','Youngest','Oldest'])
    def plates(self):
        #list of unique plate IDs
        return list(set([item.MovingPlate for item in self.rotationsets]+[item.FixedPlate for item in self.rotationsets]))

class FiniteRotationSet(object):
    """
    a collection of finite EulerRotations with common moving and fixed plates. Methods to easily list set parameters such as ages, chrons,
    generate interpolated rotations and stage rotations
    """
    def __init__(self, rotations,movingplate,fixedplate):
        #where rotations is a list of EulerRotation objects
        self.MovingPlate=movingplate
        self.FixedPlate=fixedplate
        self.rotations=rotations
        #next bit makes interpolation easier: adds in a zero age rotation if none exists
        if (self.rotations[0].EndAge==0 and self.rotations[0].StartAge==0)==False: #a possibly unneccesarilty more robust check
            newrot=copy.deepcopy(rotations[0]) #creates new rather than referenced copy
            newrot.EndAge=0.
            newrot.StartAge=0.
            newrot.RotPars.RotAng=0.
            self.rotations.insert(0,newrot)
        self.N=len(rotations)
        
    def invert(self, inverting='plate'):
        """
        returns an inverted rotationset by sequentially calling the invert method on each rotation
        By default will also invert the plate codes, set second argument to 'time'
        to invert starting and ending ages for rotation instead.
        """
        return FiniteRotationSet([rotation.invert(inverting) for rotation in self.rotations],self.FixedPlate,self.MovingPlate)
        
    def interpolate(self, ages):
        """ 
        Returns a rotation set of interpolated poles and covariances, for specified list of target ages. 
        Searches for the two bracketing rotations for each target age, following method of Doubrovine and Tarduno (2008). 
        Uses fortran routine ibfrlib0.3.f provided by Pavel Doubrovine, wrapped for python using f2py
        compiled with python wrapped using f2py
        """
        interpolated=[]
        ages.sort() #just in case
        for age in ages:
            age=float(age) #also just in case
            poleages=[item.EndAge for item in self.rotations]
            if age>=min(poleages) and age<=max(poleages):
                #check provided age is within range of given poles
                match=[rotation for rotation in self.rotations if (rotation.EndAge==age)]
                if match:
                    #checks there is a point in interpolating. If a rotation exists with the given age, can just use that.
                    interpolated.append(match[0])
                else: 
                    #get bracketing rotations
                    A1=[rotation for rotation in self.rotations if (rotation.EndAge<age)][-1]
                    A2=[rotation for rotation in self.rotations if (rotation.EndAge>age)][0]
                    xi=(age-A1.EndAge)/(A2.EndAge-A1.EndAge)
                    #do the interpolation by calling finb2       
                    newrot,newcovmat=rotkit_f.finb2(A1.RotPars.tolist(),A1.make_covmat(),A2.RotPars.tolist(),A2.make_covmat(),xi)
                    ndata=(A1.HellingerInfo.Points+A2.HellingerInfo.Points)/2 #not sure if this is justified but need something..
                    #this is admittedly a little clunky, but it does the job.
                    interpolated.append(EulerRotation(pd.Series([A1.MovingPlate,A1.FixedPlate,A1.StartChron,'None',0.,age,
                    newrot[0],newrot[1],newrot[2],
                    1.0,newcovmat[0,0],newcovmat[0,1],newcovmat[0,2],newcovmat[1,1],newcovmat[1,2],newcovmat[2,2],
                    ndata,A1.HellingerInfo.Segs,A1.HellingerInfo.Plates,A1.HellingerInfo.DOF,'Interpolated'],
                    index=['MovingPlate','FixedPlate','StartChron','EndChron','StartAge','EndAge','RotLat','RotLong',
                    'RotAng','Kappahat','a','b','c','d','e','f','Points','Segs','Plates','DOF','Source'])))
        return FiniteRotationSet(interpolated,self.MovingPlate,self.FixedPlate)
                  
    def stagerots(self):
        srots=[]
        #get the stage rotations between each finite rotation in the RotationSet.
        for rot1,rot2 in zip(self.rotations[:-1],self.rotations[1:]):  
            srot=rotmat_to_pole(rot2.make_rotmat()*np.transpose(rot1.make_rotmat()))
            #calculation of covariance matrix for stage rotation between A1 and A2 = A1*(cov2-cov1)
            #from Appendix to Doubrovine & Tarduno 2008
            cov_matrix_s=rot1.make_rotmat()*(rot2.make_covmat()-rot1.make_covmat())
            #not sure that this is totally valid - may be better to just put in smallest number of points?
            points=(rot1.HellingerInfo.Points+rot2.HellingerInfo.Points)/2
            srots.append(EulerRotation(pd.Series([self.MovingPlate,self.FixedPlate,rot1.EndChron,rot2.EndChron,rot1.EndAge,rot2.EndAge,
                    srot[0],srot[1],srot[2],
                    1.0,cov_matrix_s[0,0],cov_matrix_s[0,1],cov_matrix_s[0,2],cov_matrix_s[1,1],cov_matrix_s[1,2],cov_matrix_s[2,2],
                    points,'NA','NA',10000,'Interpolated Stage Pole'],
                    index=['MovingPlate','FixedPlate','StartChron','EndChron','StartAge','EndAge','RotLat','RotLong',
                    'RotAng','Kappahat','a','b','c','d','e','f','Points','Segs','Plates','DOF','Source'])))    
        return StageRotationSet(srots,self.MovingPlate,self.FixedPlate)
        
    def addrots(self,other_rotset,ages=[],sense='to'):
        #adds this rotationset to another one at specified age steps: if no ages provided will interpolate to all finite rotation ages 
        # Default sense is that you are adding 'to' other_rot, such that the fixed plate of other_rot is the fixed plate for the result.
        # If sense is 'on' then the fixed plate of this rotation will be the fixed plate for the result.
        if not ages:
            ages=list(set(self.summary().EndAge.tolist()+other_rotset.summary().EndAge.tolist()))
            ages.sort()
        if sense=='to':
            rotset1,rotset2=self.interpolate(ages),other_rotset.interpolate(ages)
        else:
            rotset1,rotset2=other_rotset.interpolate(ages),self.interpolate(ages)
        added=[]
        for rot1,rot2 in zip(rotset1.rotations,rotset2.rotations):
            added.append(rot1.addrot(rot2))
        return FiniteRotationSet(added,rotset1.MovingPlate,rotset2.FixedPlate)    
   
    def summary(self):
        return pd.DataFrame([[item.MovingPlate,item.FixedPlate,item.StartAge,item.EndAge,item.RotPars[0],item.RotPars[1],item.RotPars[2]] for item in self.rotations],
                                columns=['MovingPlate','FixedPlate','StartAge','EndAge','RotLat','RotLong','RotAng'])
                

class StageRotationSet(object):
    """
    a collection of stage EulerRotations with common moving and fixed plates. Methods to easily list set parameters such as ages, chrons,
    generate interpolated rotations and stage rotations
    """
    def __init__(self, rotations,movingplate,fixedplate):
        #where rotations is a list of EulerRotation objects
        #note unlike finite rotationset does not add in a zero rotation.
        self.MovingPlate=movingplate
        self.FixedPlate=fixedplate
        self.rotations=rotations
        self.N=len(rotations)
        
    def invert(self):
        """
        returns an inverted rotationset by sequentially calling the invert method on each rotation
        AFAICT inversion is only meaningful in time for stage poles, so currently that is what it does
        """
        inverted=FiniteRotationSet([rotation.invert('time') for rotation in self.rotations],self.MovingPlate,self.FixedPlate)
        #don't want zeroed rotation for stage poles
        inverted.rotations=inverted.rotations[1:]
        return inverted
                          
    def finiterots(self):
        """
        Adds the stage rotations sequentially to produce net/finite rotations.
        Rotations must be in order.
        """
        finiterots=[self.rotations[0]]
        for rotation in self.rotations[1:]:
            finiterots.append(finiterots[-1].addrot(rotation))
        return FiniteRotationSet(finiterots, self.MovingPlate,self.FixedPlate)
   
    def summary(self):
        return pd.DataFrame([[item.MovingPlate,item.FixedPlate,item.StartAge,item.EndAge,item.RotPars[0],item.RotPars[1],item.RotPars[2]] for item in self.rotations],
                                columns=['MovingPlate','FixedPlate','StartAge','EndAge','RotLat','RotLong','RotAng'])
                                  
class EulerRotation(object):
    """
    Euler rotation for objects on Earth's surface. At the moment it does not make a distinction between finite rotations
    (where one of the age points is 0) and a stage rotation: this may change if different methods are required.
    Attributes:
        MovingPlate: tectonic plate code for moving plate
        FixedPlate: tectonic plate code for fixed plate
        StartAge: starting age of rotation (will normally be 0 for loaded finite rotations)
        StartChron: magnetic chron for starting age ('None' if does not correspond to any chron due to e.g., interpolation)
        EndAge: end age of rotation
        EndChron: magnetic chron for end age ('None' if does not correspond to any chron due to e.g., interpolation)
        RotPars: pandas Series with Latitude, Longitude and Rotation Angle
        Covariances: pandas Series with kappahat and covariance values a,b,c,d,e,f
        HellingerInfo: pandas Series with Points and Segments used for Hellinger fit, 2/3 Plate system, and corresponding degrees of freedom (DOF)
        Source: Published source, or 'Calculated' if created by addition/interpolation etc.
        PlotColor: assigned colour (defaults to black)
    """
    def __init__(self, rotation, plotcolor='black'):
        """Return object
        input is a pandas DataFrame row with neccessary parameters. Should probably try to make it fail gracefully if no covariances?
        the getattr is a way of giving a default value if none is detected. So could potentially do something like that an give default covariances...
        """ 
        self.MovingPlate = rotation.MovingPlate
        self.FixedPlate=rotation.FixedPlate
        self.StartAge=getattr(rotation,'StartAge',0)
        self.EndAge=rotation.EndAge
        self.StartChron=getattr(rotation,'StartChron','None')
        self.EndChron=rotation.EndChron
        self.RotPars=pd.Series([rotation.RotLat,rotation.RotLong,rotation.RotAng],index=['RotLat','RotLong','RotAng'])
        self.Covariances=pd.Series([rotation.Kappahat,rotation.a,rotation.b,rotation.c,rotation.d,rotation.e,rotation.f],
                                    index=['Kappahat','a','b','c','d','e','f'])
        self.HellingerInfo=pd.Series([rotation.Points,rotation.Segs,rotation.Plates,rotation.DOF], index=['Points','Segs','Plates','DOF'])
        self.Source=rotation.Source
        self.PlotColor=plotcolor

    def make_covmat(self):
        return np.matrix([[self.Covariances.a,self.Covariances.b,self.Covariances.c],
                            [self.Covariances.b,self.Covariances.d,self.Covariances.e],
                            [self.Covariances.c,self.Covariances.e,self.Covariances.f]])
                            
    def make_rotmat(self):
        lat,lon,ang=self.RotPars.RotLat*np.pi/180,self.RotPars.RotLong*np.pi/180,self.RotPars.RotAng*np.pi/180,
        num=1-np.cos(ang)
        px=np.cos(lat)*np.cos(lon)
        py=np.cos(lat)*np.sin(lon)
        pz=np.sin(lat)
        return np.matrix([[(px*px*num )+ np.cos(ang),(px*py*num )-(pz*np.sin(ang)),(px*pz*num)+(py*np.sin(ang))],
                    [(py*px*num)+(pz*np.sin(ang)),(py*py*num)+np.cos(ang),(py*pz*num)-(px*np.sin(ang))],
                    [(px*pz*num)-(py*np.sin(ang)),(pz*py*num)+(px*np.sin(ang)),(pz*pz*num)+np.cos(ang)]])

    def invert(self, inverting='plate'):
        """
        Calculate the inverse of a rotation and its convariance matrix
        By default will also invert the plate codes, set second argument to 'time'
        to invert starting and ending ages for rotation instead.
        """
        # calculate inverse rotation and its covariance matrix - adapted from invrot.f (original November 3 1988 J-Y R)
        # a=b**t; cova=b*covb*(b**t) where b, covb =rotation and covariance matrices of original rotation, and a is the transpose of b
        invrot=EulerRotation(self.details())
        invrot.RotPars.RotAng=-invrot.RotPars.RotAng
        rot_matrix=invrot.make_rotmat()
        cov_matrix=invrot.make_covmat()
        t_rot_matrix=np.transpose(rot_matrix)
        inv_cov=rot_matrix*cov_matrix*t_rot_matrix
        invrot.Covariances=pd.Series([invrot.Covariances.Kappahat,inv_cov[0,0],inv_cov[0,1],inv_cov[0,2],inv_cov[1,1],inv_cov[1,2],inv_cov[2,2]],
                                    index=['Kappahat','a','b','c','d','e','f'])
        if inverting=='time': 
            invrot.StartAge=self.EndAge
            invrot.EndAge=self.StartAge
            invrot.StartChron=self.EndChron
            invrot.EndChron=self.StartChron
        else: 
            invrot.FixedPlate=self.MovingPlate
            invrot.MovingPlate=self.FixedPlate
        return invrot
        
    def addrot(self,other_rot,sense='to'):
        #adds together this rotation to another one. 
        # Default sense is that you are adding 'to' other_rot, such that the fixed plate of other_rot is the fixed plate for the result.
        # If sense is 'on' then the fixed plate of this rotation will be the fixed plate for the result.
        # Rotation vector addition adapted from fortran code provided by David Rowley, based on vector addition as described in Cox and Hart  p. 232 and 233
        # Treatment of rotation covariance per Chang 1990 - covariance of combined rotations A and B C=AB, with covariance cova and covb: covc ~= B(t)*covA*B+covB
        # a linear approximation that assumes rotations *associated with the errors* are small enough to be treated as infintesimal so can be added as vectors.
        # Condition for this that det(cova) and det (covb) <<1, which seems to be more than met with typical rotation pole covariances.
        # Adapted from addrot.f (most notes below copied from there) ======  November 3 1988 J-Y R ======= MODIFIED OCTOBER 14, 1991
      
        if sense=='to':
            rot1=EulerRotation(self.details())
            rot2=other_rot
        else:
            rot1=other_rot
            rot2=EulerRotation(self.details())
         
        #1. Check if rotation angles are 0    
        if rot1.RotPars[2]==0 and rot2.RotPars[2]==0: newRotPars=[0,0,0]
        #2. Check if poles are identical (sum to zero)
        elif -rot1.RotPars[2]==rot2.RotPars[2] and rot1.RotPars[0]==rot2.RotPars[0] and rot1.RotPars[1]==rot2.RotPars[1]: newRotPars=[rot1[0],rot1[1],0]
        elif -rot1.RotPars[2]==rot2.RotPars[2] and rot1.RotPars[0]==-rot2.RotPars[0] and rot1.RotPars[1]==rot2.RotPars[1]+180: newRotPars=[rot1[0],rot1[1],0]
        elif -rot1.RotPars[2]==rot2.RotPars[2] and rot1.RotPars[0]==-rot2.RotPars[0] and rot1.RotPars[1]==rot2.RotPars[1]-180: newRotPars=[rot1[0],rot1[1],0]
        else: newRotPars=rotmat_to_pole(rot2.make_rotmat()*rot1.make_rotmat())
        
        #now to deal with covariances. Currently, the kappa estimation when DOF<50 for one or both kappahat is not implemented.
        new_covmat=(np.transpose(rot2.make_rotmat())*(rot2.make_covmat()/rot2.Covariances.Kappahat)
                                *rot2.make_rotmat())+(rot1.make_covmat()/rot1.Covariances.Kappahat)
        newKappa=1
        newDOF=10000
        
        return EulerRotation(pd.Series([rot1.MovingPlate,rot2.FixedPlate,rot1.StartChron,rot2.EndChron,rot1.StartAge,rot2.EndAge,
                    newRotPars[0],newRotPars[1],newRotPars[2],
                    newKappa,new_covmat[0,0],new_covmat[0,1],new_covmat[0,2],new_covmat[1,1],new_covmat[1,2],new_covmat[2,2],
                    rot1.HellingerInfo.Points+rot2.HellingerInfo.Points,'NA','NA',newDOF,'Calculated'],
                    index=['MovingPlate','FixedPlate','StartChron','EndChron','StartAge','EndAge','RotLat','RotLong',
                    'RotAng','Kappahat','a','b','c','d','e','f','Points','Segs','Plates','DOF','Source']))             
    
    def rotate(self,rotation):
        """
        Rotates rotation pole by EulerRotation rotation (i.e. into a different reference frame)
        Most relevent for stage rotations: makes the FixedPlate/MovingPlate a bit tricky potentially.
        """ 
        result=rotkit_f.rotatepts(np.array([[self.RotPars.RotLat,self.RotPars.RotLong]]),
                np.array([rotation.RotPars.tolist()+rotation.Covariances.tolist()+[rotation.EndAge]]),1)
        return EulerRotation(pd.Series([self.MovingPlate,self.FixedPlate,self.StartChron,self.EndChron,self.StartAge,self.EndAge,result[:,0][0],result[:,1][0],self.RotPars[2],
                        self.Covariances.Kappahat,self.Covariances.a,self.Covariances.b,self.Covariances.c,self.Covariances.d,self.Covariances.e,self.Covariances.f,
                        self.HellingerInfo.Points,self.HellingerInfo.Segs,self.HellingerInfo.Plates,self.HellingerInfo.DOF,self.Source],
                            index=['MovingPlate','FixedPlate','StartChron','EndChron','StartAge','EndAge','RotLat','RotLong','RotAng',
                            'Kappahat','a','b','c','d','e','f','Points','Segs','Plates','DOF','Source']))
    
    def details(self):
        return pd.Series([self.MovingPlate,self.FixedPlate,self.StartChron,self.EndChron,self.StartAge,self.EndAge,self.RotPars[0],self.RotPars[1],self.RotPars[2],
                        self.Covariances.Kappahat,self.Covariances.a,self.Covariances.b,self.Covariances.c,self.Covariances.d,self.Covariances.e,self.Covariances.f,
                        self.HellingerInfo.Points,self.HellingerInfo.Segs,self.HellingerInfo.Plates,self.HellingerInfo.DOF,self.Source],
                            index=['MovingPlate','FixedPlate','StartChron','EndChron','StartAge','EndAge','RotLat','RotLong','RotAng',
                            'Kappahat','a','b','c','d','e','f','Points','Segs','Plates','DOF','Source'])
        
    def summary(self):
        return pd.Series([self.MovingPlate,self.FixedPlate,self.StartAge,self.EndAge,self.RotPars[0],self.RotPars[1],self.RotPars[2]],
                            index=['MovingPlate','FixedPlate','StartAge','EndAge','RotLat','RotLong','RotAng'])   

class Point(object):
    """ Baseclass for a point that can be acted on by rotations
    
        Attributes:
        PointName: string describing feature
        PlateCode: tectonic plate code on which point(s) are located
        LocPars: pandas Series with Latitude and Longitude, plus rotation error ellipse parameters
        FeatureAge: age of feature
        ReconstructionAge: age that current set of points has been reconstructed at
        PlotColor: assigned colour
        PlotLevel: plot level (defaults to 5)
    """    
    def __init__(self, PointPars,PlotColor='grey',PlotLevel=5):
        """Return object
        PointPars should be a Series/DataFrame row with name,PlateCode,Lat,Lon,FeatureAge,ReconstructionAge;
        optionally MaxError,MinError,MaxBearing, otherwise 0 by default
        """ 
        self.PointName = PointPars.Name
        self.PlateCode=PointPars.PlateCode
        #not sure how much, but information about reference frame could be useful
        self.ReferencePlate=PointPars.PlateCode
        self.FeatureAge=PointPars.FeatureAge
        self.ReconstructionAge=PointPars.ReconstructionAge
        #if input does not contain rotation error parameters, creates empty columns 
        if not 'MaxError' in PointPars:
            self.LocPars=pd.Series([PointPars.Lat,PointPars.Lon,0.,0.,0.],index=['PointLat','PointLong','MaxError','MinError','MaxBearing'])
        else:
            self.LocPars=pd.Series([PointPars.Lat,PointPars.Lon,PointPars.MaxError,PointPars.MinError,PointPars.MaxBearing]
                                        ,index=['PointLat','PointLong','MaxError','MinError','MaxBearing'])
        self.PlotColor=PlotColor
        self.PlotLevel=PlotLevel
    
    def mapplot(self,m,ellipseflag=0):
        """
        plots point on preexisting Basemap. if ellipseflag set to 1, will plot the associated error ellipse
        """
        self.pltx,self.plty=m(self.LocPars.PointLong,self.LocPars.PointLat)
        plt.plot(self.pltx,self.plty, 'o', color=self.PlotColor, zorder=self.PlotLevel)
        if ellipseflag==1: m.ellipse(self.LocPars.PointLong, self.LocPars.PointLat, self.LocPars.MaxError,self.LocPars.MinError,self.LocPars.MaxBearing)
    
    def rotate(self,rotation):
        """Rotates pointset by EulerRotation rotation
        """ 
        #intially tried to make a copy and modify it, but it seems you can call the object type to initialise a new version
        result=rotkit_f.rotatepts(np.array([[self.LocPars.PointLat,self.LocPars.PointLong]]),
                np.array([rotation.RotPars.tolist()+rotation.Covariances.tolist()+[rotation.EndAge]]),1)
                
        rotated=Point(pd.Series([self.PointName,self.PlateCode,self.FeatureAge,rotation.EndAge,result[:,0][0],result[:,1][0],result[:,3][0],result[:,4][0],result[:,5][0]],
                                index=['Name','PlateCode','FeatureAge','ReconstructionAge','Lat','Lon','MaxError','MinError','MaxBearing']))
        rotated.ReferencePlate=rotation.FixedPlate
        return rotated
        
    def reconstruct(self,age,refplate,rotmodel):
        """
        Finds the EulerRotation for specified age, then rotates it
        """
        #first check if the reference plate is this plate.
        if refplate==self.PlateCode:
            return self
        #another place where adding the zero rotation could trip you up.
        else: return self.rotate(rotmodel.get_rots(self.PlateCode,refplate,[age]).rotations[-1])
        
    def flowline(self,ages,refplate,rotmodel):
        """
        Finds coordinates of line that charts motion of point relative to the reference plate for the specified age points
        Current output: list of Point objects. Eventually will be a flowline object
        """
        return [self.reconstruct(age,refplate,rotmodel) for age in ages]
  
    
    def motion_vector(self,refplate,rotmodel,startage=0.78,endage=0):
        """
        calculates the magnitude and direction of the plate motion vector for this locality relative to the specified
        reference plate. By default, it will calculate the most recent interval (last 0.78 Ma of motion).
        outputs a bearing and a rate in mm/yr or km/Myr; also N-S and E-W components of velocity and total displacement. 
        """
        #velocity of point on Earth's surface=cross product of Euler vector (omega) and position vector (r)
        #N-S component of v vNS = a*|rotrate|*cos(polelat)*sin(sitelong-polelong)
        #E-W component of v vEW =  a*|rotrate|* [cos(sitelat)*sin(polelat)-sin(sitelat)*cos(polelat)*cos(sitelong-polelong)]
        #where a=Earth radius
        #rate of motion = sqrt (vNS^2+vEW^2)
        #azimuth = 90-atan[vNS/vEW]

        #get Lat and Long of starting position of point in relevant reference frame
        #if start age or endage is 0, causes problems... (because if not there is an additional 0 Ma rotation)
        if startage==0 or endage==0: rotindex=0
        else: rotindex=1
        
        reconstruction_rots=rotmodel.get_rots(self.PlateCode,refplate,[startage,endage])
        latlong=self.rotate(reconstruction_rots.rotations[rotindex]).LocPars   
        pointlat=latlong.PointLat*np.pi/180
        pointlong=latlong.PointLong*np.pi/180
        
        #get the stage rotation over the relevant interval, and invert if going forward in time (normally will be)
        stagerot=reconstruction_rots.stagerots().rotations[rotindex]
        if startage>endage:
            stagerot=stagerot.invert('time')
            
        rotlat=stagerot.RotPars.RotLat*np.pi/180
        rotlong=stagerot.RotPars.RotLong*np.pi/180
        rotrate=stagerot.RotPars.RotAng*np.pi/180
        vNS=6371.*rotrate*np.cos(rotlat)*np.sin(pointlong-rotlong)
        vEW=6371.*rotrate*(np.cos(pointlat)*np.sin(rotlat)-np.sin(pointlat)*np.cos(rotlat)*np.cos(pointlong-rotlong))
        azimuth=90.-(180/np.pi*np.arctan2(vNS,vEW))
        if azimuth<0.: azimuth=azimuth+360.
        return pd.Series([stagerot.StartAge,stagerot.EndAge,np.sqrt(vNS**2+vEW**2)/abs(stagerot.StartAge-stagerot.EndAge),
                            azimuth,np.sqrt(vNS**2+vEW**2),vNS,vEW],
                            index=['StartAge','EndAge','Rate','Bearing','Distance','NS_component','EW_component'])
                            
    def predict_DI(self,ages,rotmodel,abs_ref_frame=3):
        """
        Predicts the Declination and Inclination that should be observed from samples of age ages
        at this site - a range of ages can be used because of the possibility of remagnetisation.
        absolute_ref_frame should be an absolute or hotspot frame of reference (e.g. Pacific=3)
        """
        VGPs=rotmodel.synthetic_APWP(ages,self.PlateCode,abs_ref_frame)
        reconstruction_rots=rotmodel.get_rots(self.PlateCode,abs_ref_frame,ages)
        rotated=[self.rotate(rotation) for rotation in reconstruction_rots.rotations[1:]]
        paleoI=[np.arctan(2*np.tan(point.LocPars.PointLat*np.pi/180))*180/np.pi for point in rotated]
        pp=np.array(([np.sin((90-vgp_lat)*np.pi/180) for vgp_lat in VGPs.Lat]))
        dphi=np.array(([np.sin((vgp_lon-self.LocPars.PointLong)*np.pi/180) for vgp_lon in VGPs.Lon]))
        pm=np.array(([np.sin((90-point.LocPars.PointLat)*np.pi/180) for point in rotated]))
        paleoD=np.arcsin(pp*dphi/pm)*180/np.pi
        return pd.DataFrame(np.column_stack((ages,[point.LocPars.PointLat for point in rotated],[point.LocPars.PointLong for point in rotated],paleoD,paleoI)), 
                                        columns=['Age','Lat','Lon','PredDec','PredInc'])
        
    def summary(self):
        return pd.Series([self.PointName,self.PlateCode,self.FeatureAge,self.ReconstructionAge]+self.LocPars.tolist(),
                                index=['Name','PlateCode','FeatureAge','ReconstructionAge','Lat','Lon','MaxError','MinError','MaxBearing'])       
        
class PointSet(object):
    """ Baseclass for a set of Points assigned to the same plate that can be operated on. 
        Methods match those for Point: basically loop through them
        Mapplot plots as individual points.
    
        Attributes:
        SetName: string describing feature
        PlateCode: tectonic plate code on which points are located
        
        Other Point attributes (e.g. FeatureAge, colors may vary by point.
    """
    def __init__(self,PointList,SetName='PointSet',PlotColor='grey',PlotLevel=5):
        """Return object
        PointList should be a DataFrame with columns name,PlateCode,Lat,Lon,FeatureAge,ReconstructionAge;
        optionally MaxError,MinError,MaxBearing
        """
        self.points=[Point(point,PlotColor,PlotLevel) for i,point in PointList.iterrows()]
        self.SetName = SetName
        self.PlateCode=PointList.iloc[0].PlateCode
        #not sure how much, but information about reference frame could be useful
        self.ReferencePlate=self.PlateCode
        self.ReconstructionAge=PointList.iloc[0].ReconstructionAge

    def mapplot(self,m,ellipseflag=0):
        for point in self.points:
            point.mapplot(m,ellipseflag)
    
    def rotate(self,rotation):
        """Rotates pointset by EulerRotation rotation
        """ 
        rotated=copy.deepcopy(self)
        #this is a lot less fiddly than converting rotated point list into format where can create PointSet de novo
        rotated.points=[point.rotate(rotation) for point in self.points]
        rotated.ReferencePlate=rotation.FixedPlate
        rotated.ReconstructionAge=rotation.EndAge
        return rotated
    
    def reconstruct(self,age,refplate,rotmodel):
        """
        Finds the EulerRotation for specified age, then rotates it
        Todo: drop points where FeatureAge<ReconstructionAge?
        """
        #first check if the reference plate is this plate.
        if refplate==self.PlateCode:
            return self
        #another place where adding the zero rotation could trip you up.
        else: return self.rotate(rotmodel.get_rots(self.PlateCode,refplate,[age]).rotations[-1])
  
    def motion_vectors(self,refplate,rotmodel,age_range=[1,0]):
        """
        calculates the magnitudes and directions of the plate motion vector for each locality relative to the specified
        reference plate. By default, it will calculate the contemporary vector (last 1 Ma of motion).
        outputs bearings and rates in mm/yr or km/Myr; also N-S and E-W components of velocity and total displacement.
        """
        return pd.DataFrame([point.motion_vector(refplate,rotmodel,age_range) for point in self.points])

    def summary(self):
        return pd.DataFrame([[point.PointName,point.PlateCode,point.FeatureAge,point.ReconstructionAge]+point.LocPars.tolist() for point in self.points],
                            columns=['Name','PlateCode','FeatureAge','ReconstructionAge','Lat','Lon','MaxError','MinError','MaxBearing'])
  
               
class Boundary(PointSet):        
    """ line that can be acted on by rotations
    
        SetName: string describing feature
        PlateCode: tectonic plate code on which points are located
        ReconstructionAge: age that current set of points has been reconstructed at
        points: List of Points
    """
    def __init__(self,PointList,SetName='PointSet',PlotColor='grey',PlotLevel=5):
        """Return object
        PointList should be a DataFrame with columns name,PlateCode,Lat,Lon,FeatureAge,ReconstructionAge;
        optionally MaxError,MinError,MaxBearing
        """
        PointSet.__init__(self,PointList,SetName,PlotColor,PlotLevel)
        self.PlotColor=PlotColor
        self.PlotLevel=PlotLevel

        
    def mapplot(self,m,thickness=2):          
        self.pltx,self.plty=m(self.summary().Lon.values,self.summary().Lat.values)
        plt.plot(self.pltx,self.plty, linewidth=thickness, color=self.PlotColor, zorder=self.PlotLevel)

class Platelet(PointSet):
    """ closed Polygon that can be acted on by rotations but no defined subsegments as PlatePolygon
    
        Attributes (inherited from PointSet):
        name: string describing feature
        PlateCode: tectonic plate code on which point(s) are located
        FeatureAge: age of feature
        ReconstructionAge: age that current set of points has been reconstructed at
        LatLons: pandas DataFrame with Lat and Long points 
        PlotColor: assigned colour (defaults to grey)
        PlotLevel: plot level (defaults to 5)
    """
    def __init__(self,PointList,SetName='PointSet',PlotColor='grey',PlotLevel=5):
        """Return object
        PointList should be a DataFrame with columns name,PlateCode,Lat,Lon,FeatureAge,ReconstructionAge;
        optionally MaxError,MinError,MaxBearing
        """
        PointSet.__init__(self,PointList,SetName,PlotColor,PlotLevel)
        self.PlotColor=PlotColor
        self.PlotLevel=PlotLevel

    def mapplot(self,m,thickness=2,transparency=0.5):
        """plot polygon on specified basemap"""
        self.pltx,self.plty=m(self.summary().Lon.values,self.summary().Lat.values)
        self.polygon=Polygon(zip(self.pltx,self.plty),
                             facecolor=self.PlotColor, alpha=transparency, zorder=self.PlotLevel)
        plt.gca().add_patch(self.polygon)
        plt.plot(self.pltx,self.plty, color=self.PlotColor, linewidth=thickness,zorder=self.PlotLevel)
        
class AMS_Locality(Point):
    """ A sampling site with associated AMS data 
    New Attributes:
    AMS_info: a pandas series that contains AMS ellipsoid information (currently just lineation orientation and error)
    """
    def __init__(self, AMSpars,PlotColor='grey',PlotLevel=5,PlotSymbolSize=2):
        Point.__init__(self,AMSpars,PlotColor,PlotLevel)
        #need to add whole ellispoid info here eventually...
        self.AMS_info=pd.Series([AMSpars.AMS_max,AMSpars.max_err],index=['k_max','k_max_err'])
        self.PlotSymbolSize=PlotSymbolSize
        
    def mapplot(self,m,plottrend=0):
        """
        plottrend=1 will add the trend of the sigma1 direction to the symbol.
        """
        self.pltx,self.plty=m(self.LatLons.Lon,self.LatLons.Lat)
        plt.plot(self.pltx,self.plty, marker='o',ms=self.PlotSymbolSize, color=self.PlotColor, zorder=self.PlotLevel)
        if plottrend==1:
            trend=self.sigma_1()
            plt.quiver(self.pltx,self.plty,np.sin(trend*np.pi/180.),np.cos(trend*np.pi/180.), pivot='tip',color=self.PlotColor,zorder=self.PlotLevel)
            plt.quiver(self.pltx,self.plty,-np.sin(trend*np.pi/180.),-np.cos(trend*np.pi/180.), pivot='tip',color=self.PlotColor,zorder=self.PlotLevel)
   
    def sigma_1(self, quadrant='E'):
        s1_dir=self.AMS_info.AMS_max+90.
        a,b=np.cos(s1_dir*np.pi/180.), np.sin(s1_dir*np.pi/180.)
        if quadrant=='N':
            if a<0: s1_dir=s1_dir-180.
            elif b<0: s1_dir=s1_dir-360.
        elif quadrant=='S':
            if a>0: s1_dir=s1_dir+180.
        elif quadrant=='W':
            if b>0: s1_dir=s1_dir+180.
        elif quadrant=='E':
            if b<0: s1_dir=s1_dir-180. 
        if s1_dir>360.: s1_dir=s1_dir-360   
        return s1_dir
        
    def rotate(self,rotation):
        """Rotates pointset by EulerRotation rotation
        Also rotates the AMS_max direction: doesn't presently incorporate rotation errors
        """ 
        #to rotate the fabric eigenvector declinations,need to have some kind of reference.
        ref_lat,ref_long=sphere_point_along_bearing(self.LocPars.PointLat,self.LocPars.PointLong,self.AMS_info.k_max,0.1)
        result=rotkit_f.rotatepts(np.column_stack(([self.LocPars.PointLat,ref_lat],[self.LocPars.PointLong,ref_long])),
                np.array([rotation.RotPars.tolist()+rotation.Covariances.tolist()+[rotation.EndAge]]),1)
        #by calculating the bearing to the rotated reference point can rotate the eigenvector dec               
        rotated=AMS_Locality(pd.Series([self.PointName,self.PlateCode,self.FeatureAge,rotation.EndAge,
                                    result[:,0][0],result[:,1][0],result[:,3][0],result[:,4][0],result[:,5][0],
                                    sphere_bearing(result[:,0][0],result[:,1][0],result[:,0][1],result[:,1][1]),self.AMS_info.k_max_err],
                                index=['Name','PlateCode','FeatureAge','ReconstructionAge','Lat','Lon','MaxError','MinError','MaxBearing','AMS_max','max_err']),
                                self.PlotColor,self.PlotLevel,self.PlotSymbolSize)
        rotated.ReferencePlate=rotation.FixedPlate
        return rotated

    def strain_history(self,rotmodel,ages,converging_plate,refplate,quadrant='E',converge_on_ref=-1):
        """
        Reconstructs the strain history by rotating the locality according to the rotation model
        then calculating the relative plate motion vector from the stage pole. converge_on_ref option 
        allows you to look at plate motion vector relative to the fixed plate, rather than the deforming block itself
        """
        reconstruction_rots=rotmodel.get_rots(self.PlateCode,refplate,ages)
        if converge_on_ref<0:  
            StageRotations=[]
            #need to rotate stagerots back to reference plate
            for rot, stagerot in zip(reconstruction_rots.rotations, rotmodel.get_rots(converging_plate,self.PlateCode,ages).stagerots().rotations):
                StageRotations.append(stagerot.rotate(rot))
            StageRotations=StageRotationSet(StageRotations,self.PlateCode,converging_plate)
        else:
            StageRotations=rotmodel.get_rots(converging_plate,refplate,ages).stagerots()            
        output=[]
        for rot,stagerot in zip(reconstruction_rots.rotations[1:],StageRotations.invert().rotations):
            rotated=self.rotate(rot)
            vector=rotated.motion_vector(stagerot,quadrant)
            output.append([stagerot.StartAge,stagerot.EndAge,rotated.LatLons.Lat,rotated.LatLons.Lon,vector.Rate,vector.Bearing])
        return pd.DataFrame(output,columns=['StartAge','EndAge','Lat','Lon','Rate','Bearing'])
        

class PMag_Locality(object):
    """ A sampling site with associated AMS data 
    Attributes:
    name: string describing feature
    PlateCode
    LatLons: a pandas series that contains Latitude, Longitude and if specified error ellipse parameters MaxError,MinError,MaxBearing
    Age_info: a pandas series that contains FeatureAge, FeatureAgeError
    PMag_info: a pandas series that contains ChRM information (
    PlotColor: assigned colour
    PlotLevel: plot level (defaults to 5)
    """
    def __init__(self, AMS_data,PlotColor='grey',PlotLevel=5,PlotSymbolSize=2):
        """Return object
        
        """ 
        self.Name=AMS_data.Name
        self.PlateCode=AMS_data.Blockcode
        if not 'MaxError' in AMS_data:
            AMS_data.MaxError=0.
            AMS_data.MinError=0.
            AMS_data.MaxBearing=0.
        self.LatLons=pd.Series([AMS_data.Lat,AMS_data.Long,AMS_data.MaxError,AMS_data.MinError,AMS_data.MaxBearing]
                                ,index=['Lat','Lon','MaxError','MinError','MaxBearing'])
        if not 'ReconstructionAge' in AMS_data:
            AMS_data.ReconstructionAge=0.
        self.Age_info=pd.Series([AMS_data.Age,AMS_data.Age_err,AMS_data.ReconstructionAge],index=['FeatureAge','Age_err','ReconstructionAge'])
        self.AMS_info=pd.Series([AMS_data.AMS_max,AMS_data.max_err],index=['AMS_max','AMS_max_err'])
        self.PlotColor=PlotColor
        self.PlotLevel=PlotLevel
        self.PlotSymbolSize=PlotSymbolSize   

#class Flowline(object):
#    """
#    A set of points tracking a feature over a range of reconstruction ages
#    Attributes:      
#    name: string describing feature
#    PlateCode: tectonic plate code for point being modelled
#    FixedPlate: code for tectonic plate that point has been rotated relative to to generate flowline  
#    FlowData: pandas DataFrame with Lat and Long points + age and error ellipse parameters for flowline 
#    PlotLevel: plot level (defaults to 5)
#    
#    Methods:
#    plot
#    """
#    def __init__(self,name,MovingPlate,FixedPlate,LineData,PlotLevel=5):
#        self.name = name
#        self.PlateCode=MovingPlate
#        self.FixedPlate=FixedPlate
#        self.FlowData=LineData    # columns should be PointLat,PointLong,Age,ErrEllipseMax,ErrEllipseMin,ErrEllipseMaxBearing
#                                # also assumes that data sorted in age ascending order
#        self.PlotLevel=PlotLevel
#        
#    def mapplot(self,m,colourmap='plasma_r',plotbar='Y'):
#        age_cmap=plt.get_cmap(colourmap)
#        maxage=np.round(max(self.FlowData.Age),-1)
#        minage=np.round(min(self.FlowData.Age),-1)
#        cNorm  = colors.Normalize(vmin=minage, vmax=maxage)
#        scalarMap = cmx.ScalarMappable(norm=cNorm, cmap=age_cmap)
#        for i,thing in self.FlowData[::-1].iterrows():
#            PointColour = scalarMap.to_rgba(thing.Age)
#            x,y= m(thing.PointLong,thing.PointLat)
#            if i<len(self.FlowData)-1:
#                #draw connecting line segment with intermediate colour
#                LineSegColour=scalarMap.to_rgba(thing.Age+((thing.Age-lastAge)/2))
#                x,y=m([x0,thing.PointLong],[y0,thing.PointLat])
#                m.plot(x,y,color=LineSegColour,zorder=3, linewidth=3)
#                m.scatter(x,y,15,color=PointColour,zorder=5)
#            m.ellipse(thing.PointLong,thing.PointLat,thing.ErrEllipseMax,thing.ErrEllipseMin,thing.ErrEllipseMaxBearing,
#                            ec=PointColour,fc='None',linewidth=2,zorder=4)
#            m.ellipse(thing.PointLong,thing.PointLat,thing.ErrEllipseMax,thing.ErrEllipseMin,thing.ErrEllipseMaxBearing,
#                            fc=PointColour,alpha=0.15,linewidth=0,zorder=1)
#            x0,y0=thing.PointLong,thing.PointLat
#            lastAge=thing.Age
#        #add colorbar for age
#        if plotbar=='Y':   
#            ax1 = plt.gca()
#            #sneaky way to extend axes with right dimensions
#            divider=make_axes_locatable(ax1)
#            ax2 = divider.append_axes("bottom", size="5%", pad=0.1)
#            cb1=colorbar.ColorbarBase(ax2, cmap=age_cmap,norm=cNorm,orientation='horizontal')
#            cb1.set_label('Age (Ma)')
#
#
#class ApparentPolarWanderPath(Flowline):
#    """
#    A flowline for paleomagnetic poles - can feed in PoleLat,PoleLong,A95 (or dp/dm) and it will
#    convert that to flowdata comaptible with the plot_ell routine. Dp/dm is potentially tricky because
#    orientation of ellipse depends on the site location relative to the calculated pole - have the information, 
#    just need to make sure it's in the right form
#    """
#    def __init__(self,name,MovingPlate,FixedPlate,PoleData,PlotLevel=5):
#        super().__init__(name,MovingPlate,FixedPlate,PoleData,PlotLevel)
#        #FlowData is not correctly configured from this - need to modify.
#        #currently just deals with A95 data. Will have to modify with conditional to deal with dp/dpm
#        self.FlowData=pd.DataFrame(np.column_stack((PoleData.PoleLat,PoleData.PoleLong,PoleData.Age,PoleData.A95,PoleData.A95,np.repeat(0,len(PoleData)))),
#                                    columns=['PointLat','PointLong','Age','ErrEllipseMax','ErrEllipseMin','ErrEllipseMaxBearing'])
#        #keep PoleData because it is useful
#        self.PoleData=PoleData
#

